import{nm as V,nn as B,no as N,a8 as _,g5 as A,bQ as F,np as U,nq as j,nr as W,cn as $,ev as Q,c3 as m,k7 as K,fF as Y,fG as J,aH as X,V as Z,ns as ee,nt as te,nc as ie,hG as se,aa as H,ac as y,ad as C,ae as re}from"./vendor.1dc52be5.js";import{r as ae,i as le,l as ne,c as oe}from"./SymbolRepository.59579b48.js";import{i as k,a as g}from"./StyleDefinition.57b891ae.js";import{G as he}from"./brushes.576aab26.js";import{o as ce}from"./VTLMaterialManager.c77710e1.js";import{l as I}from"./StyleRepository.b4c0d4f1.js";import"./BidiEngine.b9926823.js";import"./CIMSymbolHelper.e5777d0e.js";import"./enums.c01b5663.js";import"./alignmentUtils.03ee467b.js";import"./definitions.52b5fae8.js";import"./number.dc47462b.js";import"./GeometryUtils.e53da643.js";import"./Utils.25ecb0e0.js";import"./ProgramTemplate.baf6faf0.js";import"./GeometryUtils.5ea26345.js";import"./MaterialKey.4c6f010e.js";import"./programUtils.f2984097.js";import"./Geometry.e891c191.js";class de{constructor(e,t){this.lockedSchemaPixelSize=e,this.isGCS=t}getLevelRowColumn(e){return this.isGCS?[e[0],e[1]>>1,e[2]>>1]:this.lockedSchemaPixelSize===256&&e[0]>0?[e[0]-1,e[1]>>1,e[2]>>1]:e}adjustLevel(e){return this.isGCS?e:this.lockedSchemaPixelSize===256?e>0?e-1:0:e}getShift(e,t){let s=0,a=0;return(this.lockedSchemaPixelSize===256||this.isGCS)&&(e[2]%2&&(s=t),e[1]%2&&(a=t)),[s,a]}getScale(e){if(this.isGCS){if(this.lockedSchemaPixelSize===512)return 4}else if(this.lockedSchemaPixelSize===256&&e===0)return 1;return 2}}function ue(l,e){const t=[],s=new ae(4096,t,()=>{const r=new V;return r.show=!1,r.parts.push({startTime:0,startOpacity:0,targetOpacity:0,show:!1}),r.parts.push({startTime:0,startOpacity:0,targetOpacity:0,show:!1}),r}),a=new le(t,s,(r,i,n)=>new ne(r,i,n,l.styleRepository,l.key.level,0),(r,i)=>{B(r,i,!1)},()=>0,r=>{const i=e.getStyleLayerByUID(r).getLayoutProperty("visibility");return!i||i.getValue()!==k.NONE});t.push(l),s.add(l),a.setScreenSize(512,512),a.continue(1/0)}class P extends oe{constructor(e,t,s,a,r){super(e,t,s),this._memCache=a,this._loader=r,this._ongoingTileRequests=new Map,this._ongoingRequestToController=new Map}destroy(){this._ongoingRequestToController.forEach(e=>e.abort()),this._ongoingRequestToController.clear(),this._ongoingTileRequests.clear()}async getVectorTile(e,t,s,a){const r=new N(e,t,s,0);let i=this._memCache.get(r.id);if(_(i))return i.retain(),i;const n=await this._getVectorTileData(r);if(A(a),!this._layer)return null;if(i=this._memCache.get(r.id),_(i))return i.retain(),i;const c=this._layer.tileInfo.getTileBounds(F(),r);return i=new U(r,c[0],c[3],512,512,this._styleRepository,this._memCache),_(n)?(i.setData(n),i.retain(),this._memCache.put(r.id,i,i.memoryUsage*i.referenced,j)):i.setData(null),i.neededForCoverage=!0,i.transforms.tileUnitsToPixels=W(1/8,0,0,0,1/8,0,0,0,1),ue(i,this._styleRepository),i}_getVectorTileData(e){const t=e.id;if(this._ongoingTileRequests.has(t))return this._ongoingTileRequests.get(t);const s=new AbortController,a={signal:s.signal},r=this._getParsedVectorTileData(e,a).then(i=>(this._ongoingTileRequests.delete(t),this._ongoingRequestToController.delete(t),i)).catch(()=>(this._ongoingTileRequests.delete(t),this._ongoingRequestToController.delete(t),null));return this._ongoingTileRequests.set(t,r),this._ongoingRequestToController.set(t,s),r}_getParsedVectorTileData(e,t){return this.fetchTileData(e,t).then(s=>this.parseTileData({key:e,data:s},t))}request(e,t){return this._loader.request(e,"binary",t)}}const M=1e-6;class E{constructor(e,t){this.spriteMosaic=e,this.glyphMosaic=t,this._brushCache=new Map,this._vtlMaterialManager=new ce}dispose(){this._brushCache&&(this._brushCache.forEach(e=>e.dispose()),this._brushCache=null),this._vtlMaterialManager=$(this._vtlMaterialManager),this.spriteMosaic.dispose(),this.glyphMosaic.dispose()}get vectorTilesMaterialManager(){return this._vtlMaterialManager}drawTile(e,t,s){const{context:a}=e,r=s.layers;s.backgroundBucketIds.length>0&&(e.renderPass="background",s.backgroundBucketIds.forEach(i=>this._renderStyleLayer(s.getLayerById(i),e,t,!0))),a.setBlendingEnabled(!1),a.setDepthTestEnabled(!0),a.setDepthWriteEnabled(!0),a.setDepthFunction(Q.LEQUAL),e.renderPass="opaque";for(let i=r.length-1;i>=0;i--)this._renderStyleLayer(r[i],e,t,!1);a.setDepthWriteEnabled(!1),a.setBlendingEnabled(!0),a.setBlendFunctionSeparate(m.ONE,m.ONE_MINUS_SRC_ALPHA,m.ONE,m.ONE_MINUS_SRC_ALPHA),e.renderPass="translucent";for(let i=0;i<r.length;i++)this._renderStyleLayer(r[i],e,t,!1);a.setDepthTestEnabled(!1),e.renderPass="symbol";for(let i=0;i<r.length;i++)this._renderStyleLayer(r[i],e,t,!1);a.bindVAO()}_renderStyleLayer(e,t,s,a=!1){if(!(a||e&&s.layerData.has(e.uid)))return;const r=e.getLayoutProperty("visibility");if(r&&r.getValue()===k.NONE)return;const{renderPass:i}=t;let n;switch(e.type){case g.BACKGROUND:if(i!=="background")return;n="vtlBackground";break;case g.FILL:if(i!=="opaque"&&t.renderPass!=="translucent")return;n="vtlFill";break;case g.LINE:if(i!=="translucent")return;n="vtlLine";break;case g.CIRCLE:if(i!=="symbol")return;n="vtlCircle";break;case g.SYMBOL:if(i!=="symbol")return;n="vtlSymbol"}const c=t.displayLevel;e.minzoom!==void 0&&e.minzoom>c+M||e.maxzoom!==void 0&&e.maxzoom<=c-M||(t.styleLayerUID=e.uid,t.styleLayer=e,this._drawWithBrush(t,s,n))}_drawWithBrush(e,t,s){if(!this._brushCache.has(s)){const a=he[s];this._brushCache.set(s,new a)}this._brushCache.get(s).drawMany(e,[t])}}let d=class extends K(Y(J)){constructor(){super(...arguments),this.type="vector-tile-3d"}initialize(){if(X(this.layer.fullExtent))return void this.addResolvingPromise(Promise.reject(new Z("vectortilelayerview:full-extent-undefined","This layer view's layer does not define a fullExtent.")));const{basemapTerrain:l,spatialReference:e,pixelRatio:t,viewingMode:s}=this.view,a=s==="local"&&!ee(e)||te.force512VTL,r=this.layer.tileInfo.spatialReference.isGeographic,i=a?this.layer.tileInfo:this.layer.tileInfo.getOrCreateCompatible(256,r?1:2),n=this._getTileInfoSupportError(i,this.layer.fullExtent);if(_(n))return this.addResolvingPromise(Promise.reject(n));const c=ie(this.view,"basemapTerrain.tilingSchemeLocked").then(()=>{const o=l.tilingScheme,p=o.pixelSize;let h;if(this.schemaHelper=new de(p,l.spatialReference.isGeographic),p===256){const f=this.layer.tileInfo.spatialReference.isGeographic;h=this.layer.tileInfo.getOrCreateCompatible(256,f?1:2)}else h=this.view.spatialReference.isGeographic?this.layer.tileInfo.getOrCreateCompatible(512,.5):this.layer.tileInfo;const u=this._getTileInfoCompatibilityError(h,o);if(u)throw u;this.tileInfo=h});this._tileHandlerController=new AbortController;const w=this.view.resourceController;this._memCache=w.memoryController.newCache(this.layer.uid,o=>{o.release()});const{style:x}=this.layer.currentStyleInfo,q=new I(x),v=l.mapTileRequester;this._tileHandler=new P(this.layer,q,t,this._memCache,v);const b=this._tileHandlerController.signal,S=o=>w.schedule(o),T=this._tileHandler.start({signal:b,schedule:S}),R=this._tileHandler.spriteMosaic;R.then(o=>{!se(b)&&this._tileHandler&&(this.painter=new E(o,this._tileHandler.glyphMosaic))}),T.then(()=>this._tileHandlerController=null);const D=()=>{this._tileHandlerController&&this._tileHandlerController.abort(),this._tileHandlerController=new AbortController,this._memCache.clear();const{style:o}=this.layer.currentStyleInfo,p=new I(o),h=new P(this.layer,p,t,this._memCache,v),u=h.start({signal:this._tileHandlerController.signal,schedule:S}),f=h.spriteMosaic;u.then(()=>this._tileHandlerController=null),this.updatingHandles.addPromise(Promise.all([u,f]).then(([,z])=>{const G=this._tileHandler,L=this.painter;this.painter=new E(z,h.glyphMosaic),this._tileHandler=h,this.emit("data-changed"),G.destroy(),L&&L.dispose()}))};this.updatingHandles.add(()=>[this.layer.currentStyleInfo,this.view.pixelRatio],D);const O=Promise.all([c,T,R]);this.addResolvingPromise(O)}destroy(){this.painter=$(this.painter),this._tileHandlerController&&(this._tileHandlerController.abort(),this._tileHandlerController=null),H(this._tileHandler),this._memCache=H(this._memCache),this._tileHandler=null}get dataLevelRange(){const l=this.tileInfo.lods,e=l[0].scale,t=l[l.length-1].scale,s=this.levelRangeFromScaleRange(e,t);return s.minLevel===1&&this.tileInfo.size[0]===256&&(s.minLevel=0),s}async fetchTile(l,e,t,s){return this._tileHandler.getVectorTile(l,e,t,s)}};y([C()],d.prototype,"layer",void 0),y([C()],d.prototype,"dataLevelRange",null),y([C()],d.prototype,"updatingProgressValue",void 0),d=y([re("esri.views.3d.layers.VectorTileLayerView3D")],d);const $e=d;export{$e as default};
