var vi=Object.defineProperty,wi=Object.defineProperties;var bi=Object.getOwnPropertyDescriptors;var Me=Object.getOwnPropertySymbols;var Si=Object.prototype.hasOwnProperty,Li=Object.prototype.propertyIsEnumerable;var ve=(n,t,e)=>t in n?vi(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e,nt=(n,t)=>{for(var e in t||(t={}))Si.call(t,e)&&ve(n,e,t[e]);if(Me)for(var e of Me(t))Li.call(t,e)&&ve(n,e,t[e]);return n},dt=(n,t)=>wi(n,bi(t));import{V as et,no as Pi,kr as zi,aH as V,a8 as F,tn as te,ip as ee,a7 as ie,ft as g,qy as Ti,aM as _t,aT as qe,od as re,sO as $i,nM as Ii,oh as Wi,cL as St,of as Lt,o5 as se,a6 as He,g0 as Ci,rw as Kt,aP as Ei,U as Ri,g5 as ne,a3 as Ai,O as je,Q as Qe,W as Fi,S as ki,X as Bi,Y as Vi,Z as Di,$ as Oi,to as we,tp as be,tq as Se,fJ as Gi,hG as Le,hD as Ki,qt as Zi,rD as Ni}from"./vendor.1dc52be5.js";import{_ as Xt,t as Xi,o as ct,s as Ui,b as Je,h as E,j as Yi,a as qi,d as Hi,i as lt,e as ji,n as Qi,$,f as ti,U as Ji,r as tr,p as er}from"./definitions.52b5fae8.js";import{f as ir,b as Y,d as I,p as rr}from"./visualVariablesUtils.7fd15dde.js";import{E as P,z as Pe,J as sr,Q as nr}from"./Utils.25ecb0e0.js";import{l as ar}from"./tileUtils.85af3d89.js";import{n as ei,r as or,d as lr,a as hr}from"./TileClipper.95bbf067.js";import{i as B,r as Pt,e as ze}from"./enums.c01b5663.js";import{s as cr,r as ii,n as ri,i as ur,a as fr,c as _r,o as dr}from"./alignmentUtils.03ee467b.js";import{x as C,w as M}from"./number.dc47462b.js";import{_ as Ut,b as mr,U as si,B as Rt,x as xt,R as pr,L as ae}from"./MaterialKey.4c6f010e.js";import{g as xr,b as yr,d as gr,n as Te}from"./CIMSymbolHelper.e5777d0e.js";import{f as Zt,o as Mr,H as vr}from"./cimAnalyzer.13178822.js";import{h as $e,M as wr}from"./GeometryUtils.5ea26345.js";import{s as ni}from"./Geometry.e891c191.js";import{l as br}from"./ExpandedCIM.b5e8a891.js";function k(n,t){if(n&&"name"in n){const e=n;return t&&t.error(new et(e.name,e.message,e.details)),!1}return!0}const Sr=1.25;class zt{constructor(t,e){this._pos=0;const i=e?this._roundToNearest(e,t.BYTES_PER_ELEMENT):40;this._array=new ArrayBuffer(i),this._buffer=new t(this._array),this._ctor=t,this._i16View=new Int16Array(this._array)}get length(){return this._pos}_roundToNearest(t,e){const i=Math.round(t);return i+(e-i%e)}_ensureSize(t){if(this._pos+t>=this._buffer.length){const e=this._roundToNearest((this._array.byteLength+t*this._buffer.BYTES_PER_ELEMENT)*Sr,this._buffer.BYTES_PER_ELEMENT),i=new ArrayBuffer(e),r=new this._ctor(i);r.set(this._buffer,0),this._array=i,this._buffer=r,this._i16View=new Int16Array(this._array)}}ensureSize(t){this._ensureSize(t)}writeF32(t){this._ensureSize(1);const e=this._pos;return new Float32Array(this._array,4*this._pos,1)[0]=t,this._pos++,e}push(t){this._ensureSize(1);const e=this._pos;return this._buffer[this._pos++]=t,e}writeFixed(t){this._buffer[this._pos++]=t}setValue(t,e){this._buffer[t]=e}i1616Add(t,e,i){this._i16View[2*t]+=e,this._i16View[2*t+1]+=i}getValue(t){return this._buffer[t]}incr(t){if(this._buffer.length<t)throw new Error("Increment index overflows the target buffer");this._buffer[t]++}decr(t){this._buffer[t]--}writeRegion(t){this._ensureSize(t.length);const e=this._pos;return this._buffer.set(t,this._pos),this._pos+=t.length,e}writeManyFrom(t,e,i){this._ensureSize(i-e);for(let r=e;r!==i;r++)this.writeFixed(t._buffer[r])}buffer(){const t=this._array.slice(0,4*this._pos);return this.destroy(),t}toArray(){const t=this._array,e=[];for(let i=0;i<t.byteLength/4;i++)e.push(t[i]);return e}seek(t){this._pos=t}destroy(){this._array=null,this._buffer=null}}const ot=new Map;function Lr(n,t,e){const{indicesPerRecord:i,multiplier:r,verticesPerRecord:s}=ot.get(n);return{recordBytes:e*Xt*Uint32Array.BYTES_PER_ELEMENT,indexBytes:r*i*e*Uint32Array.BYTES_PER_ELEMENT,vertexBytes:r*s*e*t}}ot.set(P.MARKER,{multiplier:1,indicesPerRecord:6,verticesPerRecord:4}),ot.set(P.LINE,{multiplier:1,indicesPerRecord:24,verticesPerRecord:8}),ot.set(P.FILL,{multiplier:1,indicesPerRecord:10,verticesPerRecord:10}),ot.set(P.TEXT,{multiplier:8,indicesPerRecord:6,verticesPerRecord:4}),ot.set(P.LABEL,{multiplier:8,indicesPerRecord:6,verticesPerRecord:4});class Ie{constructor(t,e,i){this._start={index:0,vertex:0};const r=Lr(t,e,i),s=e/4;this.geometryType=t,this._records=new zt(Int32Array,r.recordBytes),this._indices=new zt(Uint32Array,r.indexBytes),this._vertices=new zt(Uint32Array,r.vertexBytes),this._metrics=new zt(Float32Array,0),this._strideInt=s}serialize(t){const e=this._records.buffer(),i=this._indices.buffer(),r=this._vertices.buffer(),s=this._metrics.length?this._metrics.buffer():null,a=4*this._strideInt;return t.push(e,i,r),{stride:a,records:e,indices:i,vertices:r,metrics:s}}get strideInt(){return this._strideInt}get recordCount(){return this._records.length/Xt}get vertexCount(){return this._vertices.length/this._strideInt}get indexCount(){return this._indices.length}get indexWriter(){return this._indices}get vertexWriter(){return this._vertices}get metricWriter(){return this._metrics}vertexEnsureSize(t){this._vertices.ensureSize(t)}indexEnsureSize(t){this._indices.ensureSize(t)}recordStart(){this._start.index=this._indices.length,this._start.vertex=this._vertices.length}recordEnd(t,e,i,r,s,a,o,l){this._records.push(t),this._records.push(e),this._records.push(i),this._records.push(r),this._records.push(s),this._records.push(a),this._records.push(o),this._records.writeF32(l)}writeIndex(t){this._indices.push(t)}writeVertex(t){this._vertices.push(t)}writeVertexF32(t){this._vertices.writeF32(t)}copyLastFrom(t,e,i){const r=t._records.length-Xt,s=t._records.getValue(r),a=t._records.getValue(r+1),o=t._records.getValue(r+2),l=t._records.getValue(r+4),h=t._records.getValue(r+6),u=t._records.getValue(r+7),c=this._vertices.length,_=(t._start.vertex-this._vertices.length)/this._strideInt,d=this._indices.length,m=this.vertexCount;for(let f=t._start.index;f!==t._indices.length;f++){const p=t._indices.getValue(f);this._indices.push(p-_)}for(let f=t._start.vertex;f!==t._vertices.length;f++){const p=t._vertices.getValue(f);this._vertices.push(p)}for(let f=c;f<=this._vertices.length;f+=this._strideInt)this._vertices.i1616Add(f,e,i);this._records.push(s),this._records.push(a),this._records.push(o),this._records.push(d),this._records.push(l),this._records.push(m),this._records.push(h),this._records.push(u)}}const Bt=1,oe=2,Vt=4,le=8,he=16,Dt=32,ce=64,Ot=128;function We(n){switch(n){case Bt:case le:case Dt:return-1;case oe:case ce:return 0;case Vt:case he:case Ot:return 1}}function Ce(n){switch(n){case Bt:case oe:case Vt:return-1;case le:case he:return 0;case Dt:case ce:case Ot:return 1}}const Ee=Bt|le|Dt,Re=Vt|he|Ot,Ae=Bt|oe|Vt,Fe=Dt|ce|Ot;class Ys{constructor(t,e,i,r,s){this._hasAggregate=!1,this.hasRecords=!1,this._data={self:new Map,neighbors:new Array},this._current={geometryType:0,writer:null,overlaps:0,start:0,insertAfter:0,sortKey:0,id:0,materialKey:0,indexStart:0,vertStart:0,isDotDensity:!1,bufferingEnabled:!1,metricBoxLenPointer:0},this.hint=e,this.tileKey=t,this._hasAggregate=r,this._pixelBufferEnabled=s,this._strideOptions=i}get hasAggregates(){return this._hasAggregate}get hasPixelBufferEnabled(){return this._pixelBufferEnabled}serialize(t){const e=[];return e.push(this._serializeTileVertexData(this.tileKey,this.tileKey,this._data.self)),this._data.neighbors.forEach((i,r)=>{const s=1<<r,a=We(s),o=Ce(s),l=ar(new Pi(this.tileKey),a,o,t),h=this._serializeTileVertexData(this.tileKey,l.id,i.vertexData);h.message.bufferIds=i.displayIds,e.push(h)}),e}_serializeTileVertexData(t,e,i){var r,s,a,o,l;const h=new Array;return{message:{tileKeyOrigin:t,tileKey:e,data:{[P.MARKER]:(r=i.get(P.MARKER))==null?void 0:r.serialize(h),[P.FILL]:(s=i.get(P.FILL))==null?void 0:s.serialize(h),[P.LINE]:(a=i.get(P.LINE))==null?void 0:a.serialize(h),[P.TEXT]:(o=i.get(P.TEXT))==null?void 0:o.serialize(h),[P.LABEL]:(l=i.get(P.LABEL))==null?void 0:l.serialize(h)}},transferList:h}}featureStart(t,e){this._current.insertAfter=t,this._current.sortKey=e}featureEnd(){}recordStart(t,e,i,r){this._current.writer=this._getVertexWriter(i),this._current.overlaps=0,this._current.indexStart=this._current.writer.indexCount,this._current.vertStart=this._current.writer.vertexCount,this._current.bufferingEnabled=r,this._current.id=t,this._current.materialKey=e,this._current.geometryType=i,this._current.isDotDensity=!1,this._current.writer.recordStart()}recordCount(){return this._current.writer.recordCount}vertexCount(){return this._current.writer.vertexCount}indexCount(){return this._current.writer.indexCount}vertexEnsureSize(t){this._current.writer.vertexEnsureSize(t)}indexEnsureSize(t){this._current.writer.indexEnsureSize(t)}vertexBounds(t,e,i,r){this._current.bufferingEnabled&&this._addOverlap(t,e,i,r)}vertexWrite(t){this._current.writer.writeVertex(t)}vertexWriteF32(t){this._current.writer.writeVertexF32(t)}vertexEnd(){}vertexWriter(){return this._current.writer.vertexWriter}indexWrite(t){this._current.writer.writeIndex(t)}indexWriter(){return this._current.writer.indexWriter}metricWriter(){return this._current.writer.metricWriter}metricStart(t,e,i,r,s,a,o,l){this._current.writer=this._getVertexWriter(P.LABEL);const h=this._current.writer.metricWriter;h.push(ir(t)),h.push(e),h.push(i),h.push(r),h.push(s),h.push(a),h.push(o),h.push(l),h.push(255),this._current.metricBoxLenPointer=h.push(0)}metricEnd(){const t=this._current.writer.metricWriter;t.getValue(this._current.metricBoxLenPointer)===0&&t.seek(t.length-10)}metricBoxWrite(t,e,i,r){const s=this._current.writer.metricWriter;s.incr(this._current.metricBoxLenPointer),s.push(0),s.push(0),s.push(t),s.push(e),s.push(i),s.push(r)}recordEnd(){const t=this._current.vertStart,e=this._current.writer.vertexCount-t;if(!e)return!1;this.hasRecords=!0;const i=this._current.indexStart,r=this._current.writer.indexCount-i;if(this._current.writer.recordEnd(this._current.id,this._current.materialKey,this._current.insertAfter,i,r,t,e,this._current.sortKey),!this._pixelBufferEnabled||this._hasAggregate||this._current.overlaps===0||this._current.geometryType===P.LABEL)return!0;const s=this._current.writer;for(let a=0;a<8;a++){const o=1<<a;if(this._current.overlaps&o){this._data.neighbors[a]||(this._data.neighbors[a]={vertexData:new Map,displayIds:new Set});const l=this._data.neighbors[a],h=this._current.geometryType;if(!l.vertexData.has(h)){const m=Pe(h,this._strideOptions).geometry,f=new Ie(h,m,Xi);l.vertexData.set(h,f)}const u=l.vertexData.get(this._current.geometryType),c=8,_=512*-We(o)*c,d=512*-Ce(o)*c;u.copyLastFrom(s,_,d),l.displayIds.add(this._current.id)}}return!0}_addOverlap(t,e,i,r){const s=255^((t<0+i?Re:t>=ct-i?Ee:Re|Ee)|(e<0+r?Fe:e>=ct-r?Ae:Fe|Ae));this._current.overlaps|=s}_getVertexWriter(t){if(!this._data.self.has(t)){const e=this._data.self,i=Pe(t,this._strideOptions).geometry;e.set(t,new Ie(t,i,this.hint.records))}return this._data.self.get(t)}}const K=0,Z=100;function ke(n,t,e){return n[0]=t[0]-e[0],n[1]=t[1]-e[1],n}function ai(n,t){return Math.sqrt(n*n+t*t)}function Be(n){const t=ai(n[0],n[1]);n[0]/=t,n[1]/=t}function Pr(n,t){return ai(n[0]-t[0],n[1]-t[1])}function b(n){return typeof n=="function"}function Yt(n=2){return 1/Math.max(n,1)}function H(n,t){return[!!n.minScale&&t.scaleToZoom(n.minScale)||K,!!n.maxScale&&t.scaleToZoom(n.maxScale)||Z]}function zr(n,t){return n[t+1]}function oi(n){return n.length-1}function Tr(n){let t=0;for(let e=0;e<oi(n);e++)t+=$r(n,e);return t}function $r(n,t,e=1){const[i,r]=zr(n,t);return Math.sqrt(i*i+r*r)*e}class At{constructor(t,e,i,r,s){this._segments=t,this._index=e,this._distance=i,this._xStart=r,this._yStart=s,this._done=!1}static create(t){return new At(t,0,0,t[0][0],t[0][1])}clone(){return new At(this._segments,this._index,this._distance,this.xStart,this.yStart)}equals(t){return this._index===t._index||t._index===this._index-1&&(this._distance===0||t._distance===1)||t._index===this._index+1&&(this._distance===1||t._distance===0)}leq(t){return this._index<t._index||this._index===t._index&&this._distance<=t._distance}geq(t){return this._index>t._index||this._index===t._index&&this._distance>=t._distance}get _segment(){return this._segments[this._index+1]}get angle(){const t=this.dy,e=(0*t+-1*-this.dx)/(1*this.length);let i=Math.acos(e);return t>0&&(i=2*Math.PI-i),i}get xStart(){return this._xStart}get yStart(){return this._yStart}get x(){return this.xStart+this.distance*this.dx}get y(){return this.yStart+this.distance*this.dy}get dx(){return this._segment[0]}get dy(){return this._segment[1]}get xMidpoint(){return this.xStart+.5*this.dx}get yMidpoint(){return this.yStart+.5*this.dy}get xEnd(){return this.xStart+this.dx}get yEnd(){return this.yStart+this.dy}get length(){const{dx:t,dy:e}=this;return Math.sqrt(t*t+e*e)}get remainingLength(){return this.length*(1-this._distance)}get backwardLength(){return this.length*this._distance}get distance(){return this._distance}get done(){return this._done}hasPrev(){return this._index-1>=0}hasNext(){return this._index+1<oi(this._segments)}next(){return this.hasNext()?(this._xStart+=this.dx,this._yStart+=this.dy,this._distance=0,this._index+=1,this):null}prev(){return this.hasPrev()?(this._index-=1,this._xStart-=this.dx,this._yStart-=this.dy,this._distance=1,this):(this._done=!0,null)}_seekBackwards(t,e){const i=this.backwardLength;if(t<=i)return this._distance=(i-t)/this.length,this;let r=this.backwardLength;for(;this.prev();){if(r+this.length>t)return this._seekBackwards(t-r);r+=this.length}return this._distance=0,e?this:null}seek(t,e=!1){if(t<0)return this._seekBackwards(Math.abs(t),e);if(t<=this.remainingLength)return this._distance=(this.backwardLength+t)/this.length,this;let i=this.remainingLength;for(;this.next();){if(i+this.length>t)return this.seek(t-i,e);i+=this.length}return this._distance=1,e?this:null}}function Ir(n,t,e,i=!0){const r=Tr(n),s=At.create(n),a=r/2;if(!i)return s.seek(a),void e(s.clone(),0,a+0*t,r);const o=Math.max((r-t)/2,0),l=Math.floor(o/t),h=a-l*t;s.seek(h);for(let u=-l;u<=l;u++)s.x<512&&s.x>=0&&s.y<512&&s.y>=0&&e(s.clone(),u,a+u*t,r),s.seek(t)}function Wr(n,t){const e=t;for(let i=0;i<n.length;i++){let r=n[i];const s=[];s.push(r[0]);for(let o=1;o<r.length;o++){let[l,h]=s[o-1];l+=r[o][0],h+=r[o][1],s.push([l,h])}Cr(s,e);const a=[];a.push(s[0]);for(let o=1;o<s.length;o++){const[l,h]=s[o-1],[u,c]=s[o],_=Math.round(u-l),d=Math.round(c-h);a.push([_,d])}n[i]=a,r=a}return n}function Cr(n,t){if(t<=0)return;const i=n.length;if(i<3)return;const r=[];let s=0;r.push(0);for(let c=1;c<i;c++)s+=Pr(n[c],n[c-1]),r.push(s);t=Math.min(t,.2*s);const a=[];a.push(n[0][0]),a.push(n[0][1]);const o=n[i-1][0],l=n[i-1][1],h=ke([0,0],n[0],n[1]);Be(h),n[0][0]+=t*h[0],n[0][1]+=t*h[1],ke(h,n[i-1],n[i-2]),Be(h),n[i-1][0]+=t*h[0],n[i-1][1]+=t*h[1];for(let c=1;c<i;c++)r[c]+=t;r[i-1]+=t;const u=.5*t;for(let c=1;c<i-1;c++){let _=0,d=0,m=0;for(let f=c-1;f>=0&&!(r[f+1]<r[c]-u);f--){const p=u+r[f+1]-r[c],x=r[f+1]-r[f],y=r[c]-r[f]<u?1:p/x;if(Math.abs(y)<1e-6)break;const v=y*y,w=y*p-.5*v*x,S=y*x/t,L=n[f+1],z=n[f][0]-L[0],T=n[f][1]-L[1];_+=S/w*(L[0]*y*p+.5*v*(p*z-x*L[0])-v*y*x*z/3),d+=S/w*(L[1]*y*p+.5*v*(p*T-x*L[1])-v*y*x*T/3),m+=S}for(let f=c+1;f<i&&!(r[f-1]>r[c]+u);f++){const p=u-r[f-1]+r[c],x=r[f]-r[f-1],y=r[f]-r[c]<u?1:p/x;if(Math.abs(y)<1e-6)break;const v=y*y,w=y*p-.5*v*x,S=y*x/t,L=n[f-1],z=n[f][0]-L[0],T=n[f][1]-L[1];_+=S/w*(L[0]*y*p+.5*v*(p*z-x*L[0])-v*y*x*z/3),d+=S/w*(L[1]*y*p+.5*v*(p*T-x*L[1])-v*y*x*T/3),m+=S}a.push(_/m),a.push(d/m)}a.push(o),a.push(l);for(let c=0,_=0;c<i;c++)n[c][0]=a[_++],n[c][1]=a[_++]}class li{static getPlacement(t,e,i,r){const s=xr(e);if(!s)return null;const a=yr(t);return s.execute(a,e,i,r)}}const Tt=8,hi=n=>class extends n{constructor(...t){super(...t),this._isCIM=!1,this._vertexBoundsScale=1,this.geometryType=P.TEXT,this._aux=C(0,0,this._referenceSize,this._bitset)}bindTextInfo(t,e){t&&t.length?this._shapingInfo=zi(t,i=>gr(i,e,{scale:this._scale,angle:this._angle,xOffset:this._xOffset,yOffset:this._yOffset,hAlign:this._xAlignD,vAlign:this._yAlignD,maxLineWidth:Math.max(32,Math.min(this._lineWidth,512)),lineHeight:Ui*Math.max(.25,Math.min(this._lineHeight,4)),decoration:this._decoration,isCIM:this._isCIM})):this._shapingInfo=null}_write(t,e,i,r){const s=e.getDisplayId();this._writeGeometry(t,e,s,i,r)}_writeGeometry(t,e,i,r,s){const a=this._shapingInfo;if(V(a))return;if(F(this._textPlacement)){const l=s!=null?s:e.readLegacyGeometryForDisplay();return this._writePlacedText(t,i,l,a,r)}const o=s?te(ee(s),2):e.geometryType==="esriGeometryPolygon"?e.readCentroid():e.readGeometryForDisplay();if(!V(o)){if(o.isPoint){const[l,h]=o.coords;return!t.hasAggregates&&t.hasPixelBufferEnabled&&(l<0||l>=512||h<0||h>=512)?void 0:this._writeGlyphs(t,i,{x:l,y:h},a)}o.forEachVertex((l,h)=>this._writeGlyphs(t,i,{x:l,y:h},a))}}_writePlacedText(t,e,i,r,s){const a=ie(this._textPlacement),o=li.getPlacement(i,a,g(1),s.geometryEngine);if(!o)return;let l=o.next();for(;l!=null;){const h=-l.getAngle();r.setRotation(h);const u=l.tx,c=-l.ty;u<0||u>=512||c<0||c>=512||(this._writeGlyphs(t,e,{x:u,y:c},r),r.setRotation(-h)),l=o.next()}}_writeGlyphs(t,e,i,r){const s=Ut.load(this._materialKey),a=M(Math.round(Tt*i.x),Math.round(Tt*i.y)),o=this._vertexBoundsScale,l=r.bounds,h=2*Math.max(l.width,l.height);for(const u of r.glyphs)s.textureBinding=u.textureBinding,t.recordStart(e,s.data,this.geometryType,!0),t.vertexBounds(i.x+l.x+this._xOffset,i.y+l.y-this._yOffset,h*o,h*o),this._writeVertices(t,e,a,u),t.recordEnd()}_writeGlyph(t,e,i,r,s){const a=Ut.load(this._materialKey),o=M(Math.round(Tt*i),Math.round(Tt*r));a.textureBinding=s.textureBinding,t.recordStart(e,a.data,this.geometryType,!0);const l=s.bounds,h=this._vertexBoundsScale;t.vertexBounds(i+l.x*h,r+l.y*h,l.width*h,l.height*h),this._writeVertices(t,e,o,s),t.recordEnd()}_writeVertices(t,e,i,r){const s=t.vertexCount();this._writeVertexCommon(t,e,i,r),t.vertexWrite(r.offsets.upperLeft),t.vertexWrite(r.texcoords.upperLeft),t.vertexEnd(),this._writeVertexCommon(t,e,i,r),t.vertexWrite(r.offsets.upperRight),t.vertexWrite(r.texcoords.upperRight),t.vertexEnd(),this._writeVertexCommon(t,e,i,r),t.vertexWrite(r.offsets.lowerLeft),t.vertexWrite(r.texcoords.lowerLeft),t.vertexEnd(),this._writeVertexCommon(t,e,i,r),t.vertexWrite(r.offsets.lowerRight),t.vertexWrite(r.texcoords.lowerRight),t.vertexEnd(),t.indexWrite(s+0),t.indexWrite(s+1),t.indexWrite(s+2),t.indexWrite(s+1),t.indexWrite(s+3),t.indexWrite(s+2)}_writeVertexCommon(t,e,i,r){const s=this._color,a=this._haloColor,o=C(0,0,this._referenceSize,this._bitset),l=C(0,0,this._size,this._haloSize);t.vertexWrite(i),t.vertexWrite(e),t.vertexWrite(s),t.vertexWrite(a),t.vertexWrite(l),t.vertexWrite(o),t.vertexWrite(this._minMaxZoom)}};class wt{bindFeature(t,e,i){}write(t,e,i,r){var s;if(V(this._effects)||((s=this._effects)==null?void 0:s.length)===0)return this._write(t,e,r);const a=Zt.executeEffects(this._effects,e.readLegacyGeometryForDisplay(),r.geometryEngine);let o=Zt.next(a);for(;o;)this._write(t,e,r,o),o=Zt.next(a)}_write(t,e,i,r){}}const Er=5;class ut extends hi(wt){constructor(t,e,i,r,s,a,o,l,h,u,c,_,d,m,f,p,x,y,v=!1,w,S){super(),this._xOffset=g(d),this._yOffset=g(m),this._decoration=u||"none",this._color=s,this._haloColor=a,this._haloSize=Math.min(Math.floor(Er*g(Ti(i))),127),this._size=Math.min(Math.round(g(e)),127);const L=Math.min(Math.round(g(r||e)),127);this._referenceSize=Math.round(Math.sqrt(256*L)),this._scale=this._size/Je,this._angle=_,this._justify=cr(o||"center"),this._xAlignD=ii(o||"center"),this._yAlignD=ri(l||"baseline"),this._baseline=(l||"baseline")==="baseline",this._bitset=(h===B.MAP?1:0)|(c?1:0)<<1;const z=Ut.load(t);z.sdf=!0,this._materialKey=z.data,this._lineWidth=g(f)||512,this._lineHeight=p||1,this._textPlacement=x,this._effects=y,this._isCIM=v,this._minMaxZoom=M(Math.round(w*E),Math.round(S*E))}static fromText(t,e){const i=new ut(t.materialKey,t.font.size,t.haloSize||0,t.font.size,t.color&&Y(t.color)||0,t.haloColor&&Y(t.haloColor)||0,t.horizontalAlignment,t.verticalAlignment,B.SCREEN,t.font.decoration,!1,t.angle||0,t.xoffset,t.yoffset,t.lineWidth,t.lineHeight,null,null,!1,K,Z),[,r]=Te(t.text);return i.bindTextInfo(e,r),i._vertexBoundsScale=t.maxVVSize?t.maxVVSize/t.font.size:1,i}static fromCIMText(t,e,i){const r=t.scaleFactor||1,s=t.size*t.sizeRatio*r,[a,o]=H(t.scaleInfo,i),l=new ut(t.materialKey,s,t.outlineSize*t.sizeRatio,t.referenceSize,I(t.color),I(t.outlineColor),t.horizontalAlignment,t.verticalAlignment,t.alignment,t.decoration,t.colorLocked,t.angle,t.offsetX*t.sizeRatio*r,t.offsetY*t.sizeRatio*r,512,1,t.markerPlacement,t.effects,!0,a,o),[,h]=Te(t.text);return l.bindTextInfo(e,h),l._vertexBoundsScale=t.maxVVSize?t.maxVVSize/s:1,l}}const Rr=_t.getLogger("esri.views.2d.engine.webgl.WGLLabelTemplate"),Ar=(n,t="mapview-labeling")=>Rr.error(new et(t,n)),$t=1,at=0,Fr=4;function kr(n,t){const e=!!n.minScale&&t.scaleToZoom(n.minScale)||0;return qe(e,0,25.5)}function Br(n,t){const e=!!n.maxScale&&t.scaleToZoom(n.maxScale)||255;return qe(e,0,25.5)}function Vr(n){const t=new Map;return e=>(t.has(e)||t.set(e,n(e)),t.get(e))}const Dr=Vr(n=>{let t=0;if(n===0)return 1/0;for(;!(n%2);)t++,n/=2;return t}),It=n=>Math.floor(127*n+127),mt=n=>Math.floor(10*n),Wt=n=>Math.round(n*(254/360));class Ft extends ut{constructor(t,e,i,r){var s,a,o;super(t,i.font.size,i.haloSize||0,i.font.size,i.color&&Y(i.color)||0,i.haloColor&&Y(i.haloColor)||0,i.horizontalAlignment,i.verticalAlignment,ur(e.labelPlacement)?B.MAP:B.SCREEN,i.font.decoration,!1,i.angle||0,i.xoffset,i.yoffset,i.lineWidth,i.lineHeight,null,null,null,null,null),this._outLineLabelAngle=0,this._refPlacementPadding=0,this._refPlacementDirX=0,this._refPlacementDirY=0,this._refOffsetX=0,this._refOffsetY=0,this._zoomLevel=0,this.geometryType=P.LABEL,this._allowOverrun=(s=e.allowOverrun)!=null&&s,this._repeatLabel=(a=e.repeatLabel)==null||a,this._labelPosition=(o=e.labelPosition)!=null?o:"curved";const l=kr(e,r),h=Br(e,r),u=e.labelPlacement,[c,_]=fr(u);this._xAlignD=c,this._yAlignD=_,this._minZoom=l,this._maxZoom=h,this._refPlacementPadding=g(i.haloSize)+Yi,this._repeatLabelDistance=e.repeatLabelDistance?g(e.repeatLabelDistance):128;const d=mr.load(t);d.sdf=!0,this._materialKey=d.data}static fromLabelClass(t,e){if(t.labelPlacement==="esriServerLinePlacementCenterAlong"){const i=t.symbol;i.xoffset=0,i.yoffset=0,i.angle=0,i.font.decoration="none"}return new Ft(t.materialKey,t,t.symbol,e)}get _shapedBox(){return ie(this._shapingInfo).bounds}setZoomLevel(t){this._zoomLevel=t}bindReferenceTemplate(t){let e=_r(this._xAlignD),i=dr(this._yAlignD);if(this._refOffsetX=0,this._refOffsetY=0,V(t))return void(this._refSymbolAndPlacementOffset=C(0,0,It(e),It(i)));if(t.boundsType==="circle"&&(e||i)){const a=Math.sqrt(e*e+i*i);e/=a,i/=a}const r=Math.max(t.height,t.width),s=this._refPlacementPadding*Fr;this._refSymbolAndPlacementOffset=C(s,r,It(e),It(i)),this._referenceSize=r,this._refPlacementDirX=e,this._refPlacementDirY=i,this._refOffsetX=t.xOffset,this._refOffsetY=t.yOffset}_write(t,e){if(V(this._shapingInfo))return;const i=this._shapingInfo,r=e.getDisplayId(),s=e.geometryType==="esriGeometryPolygon"?e.readLegacyCentroid():e.readLegacyGeometry();if(s)switch(this.current={out:t,inId:r,inShaping:i,zoomLevel:this._zoomLevel},e.geometryType){case"esriGeometryPolyline":this._placeLineLabels(s);break;case"esriGeometryPoint":case"esriGeometryPolygon":this._placePointLabels(s);break;default:Ar("mapview-labeling",`Geometry of type ${e.geometryType} is not supported`)}}_isVisible(t,e){const i=mt(this.current.zoomLevel);return mt(t)<=i&&i<=mt(e)}_placePointLabels(t){const{out:e,inId:i,inShaping:r}=this.current;this._writeGlyphs(e,i,t,r)}_placeLineLabels(t){const e=Wr(t.paths,this.current.inShaping.bounds.width),i=this._placeSubdivGlyphs.bind(this),r=(this._shapedBox.width+this._repeatLabelDistance)/(1<<$t);for(const s of e)Ir(s,r,i,this._repeatLabel)}_placeSubdivGlyphs(t,e,i,r){const s=Dr(e),a=this._shapedBox.width/(1<<$t),o=Math.sqrt(this._repeatLabelDistance)/(1<<$t),l=Math.min(i,r-i),h=Math.log2(l/(o+a/2)),u=e===0?h:Math.min(s,h),c=Math.max(this._minZoom,this.current.zoomLevel+$t-u),_=this.current.zoomLevel-c,d=this._shapedBox.width/2*2**_;this.current.inShaping.isMultiline?e===0&&this._placeStraight(t,c):this._allowOverrun&&_<0?this._placeStraightAlong(t,this._minZoom):this._labelPosition==="parallel"?this._placeStraightAlong(t,c):this._labelPosition==="curved"&&this._placeCurved(t,c,d)}_placeStraight(t,e){const{out:i,inId:r,inShaping:s}=this.current;this._writeGlyphs(i,r,t,s,e)}_placeCurved(t,e,i){const{out:r,inId:s}=this.current;r.metricStart(s,e,t.x,t.y,0,0,0,0);const a=t.clone(),o=t.angle*(180/Math.PI)%360,l=(t.angle*(180/Math.PI)+180)%360;this._outLineLabelAngle=Wt(o),this._placeFirst(a,e,1),this._placeBack(t,a,e,i,1),this._placeForward(t,a,e,i,1),this._outLineLabelAngle=Wt(l),this._placeFirst(a,e,0),this._placeBack(t,a,e,i,0),this._placeForward(t,a,e,i,0),r.metricEnd()}_placeStraightAlong(t,e){const{out:i,inId:r}=this.current;i.metricStart(r,e,t.x,t.y,0,0,0,0);const s=t.clone(),a=t.angle*(180/Math.PI)%360,o=(t.angle*(180/Math.PI)+180)%360;this._outLineLabelAngle=Wt(a),this._placeFirst(s,e,1,!0),this._outLineLabelAngle=Wt(o),this._placeFirst(s,e,0,!0),i.metricEnd()}_placeBack(t,e,i,r,s){const a=t.clone();let o=t.backwardLength+at;for(;a.prev()&&!(o>=r);)this._placeOnSegment(a,e,o,i,-1,s),o+=a.length+at}_placeForward(t,e,i,r,s){const a=t.clone();let o=t.remainingLength+at;for(;a.next()&&!(o>=r);)this._placeOnSegment(a,e,o,i,1,s),o+=a.length+at}_placeFirst(t,e,i,r=!1){const s=t,a=this.current.inShaping,o=a.glyphs,l=this.current.zoomLevel,{out:h,inId:u}=this.current;for(const c of o){const _=c.x>a.bounds.x?i:1-i,d=_*t.remainingLength+(1-_)*t.backwardLength,m=Math.abs(c.x+c.width/2-a.bounds.x),f=Math.max(0,l+Math.log2(m/(d+at))),p=Math.max(e,r?0:f);if(c.maxZoom=25,c.angle=t.angle+(1-i)*Math.PI,c.minZoom=p,this._writeGlyph(h,u,s.x,s.y,c),i&&this._isVisible(c.minZoom,c.maxZoom)){const x=c.bounds;h.metricBoxWrite(x.center[0],x.center[1],x.width,x.height)}}}_placeOnSegment(t,e,i,r,s,a){const o=this.current.inShaping.glyphs,{out:l,inId:h}=this.current,u=this.current.inShaping,c=this.current.zoomLevel,_=t.dx/t.length,d=t.dy/t.length,m={x:t.x+i*-s*_,y:t.y+i*-s*d};for(const f of o){const p=f.x>u.bounds.x?a:1-a;if(!(p&&s===1||!p&&s===-1))continue;const x=Math.abs(f.x+f.width/2-u.bounds.x),y=Math.max(0,c+Math.log2(x/i)-.1),v=Math.max(r,c+Math.log2(x/(i+t.length+at)));if(y!==0&&(f.angle=t.angle+(1-a)*Math.PI,f.minZoom=v,f.maxZoom=y,this._writeGlyph(l,h,m.x,m.y,f),a&&this._isVisible(f.minZoom,f.maxZoom))){const w=f.bounds,S=t.x-e.x,L=t.y-e.y;l.metricBoxWrite(w.center[0]+S,w.center[1]+L,w.width,w.height)}}}_writeGlyphs(t,e,i,r,s=this._minZoom){if(i.x<0||i.x>=512||i.y<0||i.y>=512)return;const a=i.x+this._refOffsetX,o=i.y-this._refOffsetY;for(const c of r.glyphs)c.minZoom=s,c.maxZoom=this._maxZoom,this._writeGlyph(t,e,a,o,c);const l=this._refPlacementDirX,h=this._refPlacementDirY,u=r.boundsT;t.metricStart(e,s,a,o,l,h,this._referenceSize,this._materialKey),t.metricBoxWrite(u.center[0],u.center[1],u.width,u.height),t.metricEnd()}_writeVertexCommon(t,e,i,r){const s=this._color,a=this._haloColor,o=C(0,0,this._size,this._haloSize),l=Math.max(r.minZoom,this._minZoom),h=Math.min(r.maxZoom,this._maxZoom),u=C(mt(l),mt(h),this._outLineLabelAngle,0);t.vertexWrite(i),t.vertexWrite(e),t.vertexWrite(s),t.vertexWrite(a),t.vertexWrite(o),t.vertexWrite(this._refSymbolAndPlacementOffset),t.vertexWrite(u)}}const Ve=3.14159265359/180,De=8,ci=n=>class extends n{constructor(...t){super(...t),this.angle=0,this.xOffset=0,this.yOffset=0,this.width=0,this.height=0,this.boundsType="square",this._anchorX=0,this._anchorY=0,this._computedWidth=0,this._computedHeight=0,this._vertexBoundsScaleX=1,this._vertexBoundsScaleY=1,this._offsets={xUpperLeft:0,yUpperLeft:0,xUpperRight:0,yUpperRight:0,xBottomLeft:0,yBottomLeft:0,xBottomRight:0,yBottomRight:0},this.geometryType=P.MARKER}_write(t,e,i,r){const s=e.getDisplayId();t.recordStart(s,this._materialKey,this.geometryType,!0),this._writeGeometry(t,e,s,i,r),t.recordEnd()}_writeGeometry(t,e,i,r,s){if(F(this._markerPlacement))return this._writePlacedMarkers(t,e,r,s);if(!s&&e.geometryType==="esriGeometryPoint"){const o=e.getX(),l=e.getY();return!t.hasAggregates&&t.hasPixelBufferEnabled&&(o<0||o>=513||l<0||l>=513)?void 0:this._writeVertices(t,i,this._getPos(o,l),o,l)}const a=s?te(ee(s),2):e.geometryType==="esriGeometryPolygon"?e.readCentroid():e.readGeometryForDisplay();if(!V(a)){if(a.isPoint){const[o,l]=a.coords;return!t.hasAggregates&&t.hasPixelBufferEnabled&&(o<0||o>=512||l<0||l>=512)?void 0:this._writeVertices(t,i,this._getPos(o,l),o,l)}a.forEachVertex((o,l)=>this._writeVertices(t,i,this._getPos(o,l),o,l))}}_writePlacedMarkers(t,e,i,r){const s=r!=null?r:e.readLegacyGeometryForDisplay(),a=li.getPlacement(s,ie(this._markerPlacement),g(1),i.geometryEngine);if(!a)return;const o=e.getDisplayId(),l=se(),h=re(),u=-128,c=640;let _=a.next();for(;_!=null;){const d=_.tx,m=-_.ty;d>=u&&d<=c&&m>=u&&m<=c&&(this._applyTransformation(h,l,-_.getAngle()/Ve),this._writeVertices(t,o,this._getPos(d,m),d,m)),_=a.next()}}_writeVertices(t,e,i,r,s){const a=t.vertexCount();if(this.angle){const o=Math.max(this._computedWidth*this._vertexBoundsScaleX,this._computedHeight*this._vertexBoundsScaleY);t.vertexBounds(r+this.xOffset,s-this.yOffset,o,o)}else t.vertexBounds(r+this.xOffset,s-this.yOffset,this._computedWidth*this._vertexBoundsScaleX,this._computedHeight*this._vertexBoundsScaleY);t.vertexWrite(i),t.vertexWrite(this._offsetUpperLeft),t.vertexWrite(this._texUpperLeft),t.vertexWrite(this._bitestAndDistRatio),t.vertexWrite(e),t.vertexWrite(this._fillColor),t.vertexWrite(this._outlineColor),t.vertexWrite(this._sizeOutlineWidth),t.vertexWrite(this._minMaxZoom),t.vertexEnd(),t.vertexWrite(i),t.vertexWrite(this._offsetUpperRight),t.vertexWrite(this._texUpperRight),t.vertexWrite(this._bitestAndDistRatio),t.vertexWrite(e),t.vertexWrite(this._fillColor),t.vertexWrite(this._outlineColor),t.vertexWrite(this._sizeOutlineWidth),t.vertexWrite(this._minMaxZoom),t.vertexEnd(),t.vertexWrite(i),t.vertexWrite(this._offsetBottomLeft),t.vertexWrite(this._texBottomLeft),t.vertexWrite(this._bitestAndDistRatio),t.vertexWrite(e),t.vertexWrite(this._fillColor),t.vertexWrite(this._outlineColor),t.vertexWrite(this._sizeOutlineWidth),t.vertexWrite(this._minMaxZoom),t.vertexEnd(),t.vertexWrite(i),t.vertexWrite(this._offsetBottomRight),t.vertexWrite(this._texBottomRight),t.vertexWrite(this._bitestAndDistRatio),t.vertexWrite(e),t.vertexWrite(this._fillColor),t.vertexWrite(this._outlineColor),t.vertexWrite(this._sizeOutlineWidth),t.vertexWrite(this._minMaxZoom),t.vertexEnd(),t.indexWrite(a+0),t.indexWrite(a+1),t.indexWrite(a+2),t.indexWrite(a+1),t.indexWrite(a+3),t.indexWrite(a+2)}_applyTransformation(t,e,i=0){$i(t,Ii(this.xOffset,-this.yOffset)),this.angle+i!==0&&Wi(t,t,Ve*(this.angle+i));const r=this._computedWidth,s=this._computedHeight,a=(this._anchorX-.5)*r,o=(this._anchorY-.5)*s;St(e,a,o),Lt(e,e,t),this._offsetUpperLeft=M(16*e[0],16*e[1]),this._offsets.xUpperLeft=e[0],this._offsets.yUpperLeft=e[1],St(e,a+r,o),Lt(e,e,t),this._offsetUpperRight=M(16*e[0],16*e[1]),this._offsets.xUpperRight=e[0],this._offsets.yUpperRight=e[1],St(e,a,o+s),Lt(e,e,t),this._offsetBottomLeft=M(16*e[0],16*e[1]),this._offsets.xBottomLeft=e[0],this._offsets.yBottomLeft=e[1],St(e,a+r,o+s),Lt(e,e,t),this._offsetBottomRight=M(16*e[0],16*e[1]),this._offsets.xBottomRight=e[0],this._offsets.yBottomRight=e[1]}_getPos(t,e){return M(Math.round(De*t),Math.round(De*e))}};class G extends ci(wt){constructor(t,e,i,r,s,a,o,l,h,u,c,_,d,m,f,p,x,y,v,w,S,L,z){super(),this.angle=r,this.height=o,this.width=a,this.xOffset=e*v,this.yOffset=i*v,this._markerPlacement=w,this._effects=S,this._anchorX=.5-(.5+p)*f.width/f.width,this._anchorY=.5-(.5+x)*f.height/f.height,this._minMaxZoom=M(Math.round(L*E),Math.round(z*E));const T=(m===B.MAP?qi:Hi)|(c?lt:0)|(d?ji:0)|(_?Qi:0),rt=f&&f.sdf,j=si.load(t);j.sdf=rt,j.pattern=!0,j.textureBinding=f.textureBinding,this._materialKey=j.data,this._fillColor=s,this._outlineColor=h,this._sizeOutlineWidth=C(Math.round(Math.min(Math.sqrt(128*a),255)),Math.round(Math.min(Math.sqrt(128*o),255)),Math.round(Math.min(Math.sqrt(128*u),255)),Math.round(Math.min(Math.sqrt(128*l),255)));const D=f.rect.x+$,Q=f.rect.y+$,st=D+f.width,bt=Q+f.height;this._offsets.xUpperLeft=D,this._offsets.yUpperLeft=Q,this._offsets.xUpperRight=st,this._offsets.yUpperRight=Q,this._offsets.xBottomLeft=D,this._offsets.yBottomLeft=bt,this._offsets.xBottomRight=st,this._offsets.yBottomRight=bt,this._texUpperLeft=M(D,Q),this._texUpperRight=M(st,Q),this._texBottomLeft=M(D,bt),this._texBottomRight=M(st,bt),a*=y,o*=y,a*=v,o*=v;const yi=Math.round(64*y);this._bitestAndDistRatio=M(T,yi),this._computedWidth=a,this._computedHeight=o;const gi=se(),Mi=re();this._applyTransformation(Mi,gi)}static fromCIMMarker(t,e,i){const r=e&&e.width||1,s=e&&e.height||1,a=t.size,o=r/s*t.scaleX,l=t.scaleSymbolsProportionally&&t.frameHeight?a/t.frameHeight:1;let h=I(t.color);const u=I(t.outlineColor),c=g(a),_=c*o,d=g(t.offsetX||0),m=g(t.offsetY||0),f=g(t.outlineWidth||0)*l,p=t.alignment||B.SCREEN,x=g(t.referenceSize),[y,v]=H(t.scaleInfo,i);e.sdf||h!==0||(h=-1);let w=t.rotation||0;t.rotateClockwise||(w=-w);let S=0,L=0;const z=t.anchorPoint;z&&(t.isAbsoluteAnchorPoint?a&&(S=-z.x/(a*o),L=z.y/a):(S=z.x,L=z.y));const T=new G(t.materialKey,d,m,w,h,_,c,x,u,f,t.colorLocked,t.scaleSymbolsProportionally,!1,p,e,S,L,t.sizeRatio,He(t.scaleFactor,1),t.markerPlacement,t.effects,y,v);return T._vertexBoundsScaleX=t.maxVVSize?t.maxVVSize/_:1,T._vertexBoundsScaleY=t.maxVVSize?t.maxVVSize/c:1,T}static fromPictureMarker(t,e){const i=Math.round(g(t.width)),r=Math.round(g(t.height)),s=ti,a=Math.round(g(t.xoffset||0)),o=Math.round(g(t.yoffset||0)),l=new G(t.materialKey,a,o,t.angle,s,i,r,r,0,0,!1,!1,!1,B.SCREEN,e,0,0,1,1,null,null,K,Z);return l._vertexBoundsScaleX=t.maxVVSize?t.maxVVSize/t.width:1,l._vertexBoundsScaleY=t.maxVVSize?t.maxVVSize/t.height:1,l}static fromSimpleMarker(t,e){const i=Y(t.color),r=Math.round(g(t.size)),s=r,a=Math.round(g(t.xoffset||0)),o=Math.round(g(t.yoffset||0)),l=t.style,h=t.outline,u=0|(h&&h.color&&Y(h.color)),c=0|(h&&h.width&&Math.round(g(h.width))),_=new G(t.materialKey,a,o,t.angle,i,r,s,s,u,c,!1,!1,l==="esriSMSCross"||l==="esriSMSX",B.SCREEN,e,0,0,126/64,1,null,null,K,Z);return _.boundsType=l==="esriSMSCircle"?"circle":"square",_._vertexBoundsScaleX=t.maxVVSize?t.maxVVSize/t.size:1,_._vertexBoundsScaleY=t.maxVVSize?t.maxVVSize/t.size:1,_}static fromLineSymbolMarker(t,e){const i=Y(t.color),r=6,s=Math.round(g(r*t.lineWidth)),a=s,o=t.style==="cross"||t.style==="x";let l;switch(t.placement){case"begin-end":l=Pt.Both;break;case"begin":l=Pt.JustBegin;break;case"end":l=Pt.JustEnd;break;default:l=Pt.None}const h={type:"CIMMarkerPlacementAtExtremities",angleToLine:!0,offset:0,extremityPlacement:l,offsetAlongLine:0},u=new G(t.materialKey,0,0,0,i,s,a,a/r,i,o?Math.round(g(t.lineWidth)):0,!1,!1,o,B.MAP,e,0,0,126/64,1,h,null,K,Z);return u.boundsType=t.style==="circle"?"circle":"square",u}}function Or(n,t,e,i,r,s,a){jt=0;const o=(i-e)*s,l=r&&r.length,h=l?(r[0]-e)*s:o;let u,c,_,d,m,f=ui(t,e,i,0,h,s,!0);if(f&&f.next!==f.prev){if(l&&(f=Nr(t,e,i,r,f,s)),o>80*s){u=_=t[0+e*s],c=d=t[1+e*s];for(let p=s;p<h;p+=s){const x=t[p+e*s],y=t[p+1+e*s];u=Math.min(u,x),c=Math.min(c,y),_=Math.max(_,x),d=Math.max(d,y)}m=Math.max(_-u,d-c),m=m!==0?1/m:0}gt(f,n,s,u,c,m,a,0)}}function ui(n,t,e,i,r,s,a){let o;if(a===Hr(n,t,e,i,r,s)>0)for(let l=i;l<r;l+=s)o=Oe(l+t*s,n[l+t*s],n[l+1+t*s],o);else for(let l=r-s;l>=i;l-=s)o=Oe(l+t*s,n[l+t*s],n[l+1+t*s],o);return o&&tt(o,o.next)&&(Mt(o),o=o.next),o}function yt(n,t=n){if(!n)return n;let e,i=n;do if(e=!1,i.steiner||!tt(i,i.next)&&W(i.prev,i,i.next)!==0)i=i.next;else{if(Mt(i),i=t=i.prev,i===i.next)break;e=!0}while(e||i!==t);return t}function gt(n,t,e,i,r,s,a,o){if(!n)return;!o&&s&&(n=fi(n,i,r,s));let l=n;for(;n.prev!==n.next;){const h=n.prev,u=n.next;if(s?Kr(n,i,r,s):Gr(n))t.push(h.index/e+a),t.push(n.index/e+a),t.push(u.index/e+a),Mt(n),n=u.next,l=u.next;else if((n=u)===l){o?o===1?gt(n=Qr(n,t,e,a),t,e,i,r,s,a,2):o===2&&Jr(n,t,e,i,r,s,a):gt(yt(n),t,e,i,r,s,a,1);break}}}function Gr(n){const t=n.prev,e=n,i=n.next;if(W(t,e,i)>=0)return!1;let r=n.next.next;const s=r;let a=0;for(;r!==n.prev&&(a===0||r!==s);){if(a++,ht(t.x,t.y,e.x,e.y,i.x,i.y,r.x,r.y)&&W(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}function Kr(n,t,e,i){const r=n.prev,s=n,a=n.next;if(W(r,s,a)>=0)return!1;const o=r.x<s.x?r.x<a.x?r.x:a.x:s.x<a.x?s.x:a.x,l=r.y<s.y?r.y<a.y?r.y:a.y:s.y<a.y?s.y:a.y,h=r.x>s.x?r.x>a.x?r.x:a.x:s.x>a.x?s.x:a.x,u=r.y>s.y?r.y>a.y?r.y:a.y:s.y>a.y?s.y:a.y,c=qt(o,l,t,e,i),_=qt(h,u,t,e,i);let d=n.prevZ,m=n.nextZ;for(;d&&d.z>=c&&m&&m.z<=_;){if(d!==n.prev&&d!==n.next&&ht(r.x,r.y,s.x,s.y,a.x,a.y,d.x,d.y)&&W(d.prev,d,d.next)>=0||(d=d.prevZ,m!==n.prev&&m!==n.next&&ht(r.x,r.y,s.x,s.y,a.x,a.y,m.x,m.y)&&W(m.prev,m,m.next)>=0))return!1;m=m.nextZ}for(;d&&d.z>=c;){if(d!==n.prev&&d!==n.next&&ht(r.x,r.y,s.x,s.y,a.x,a.y,d.x,d.y)&&W(d.prev,d,d.next)>=0)return!1;d=d.prevZ}for(;m&&m.z<=_;){if(m!==n.prev&&m!==n.next&&ht(r.x,r.y,s.x,s.y,a.x,a.y,m.x,m.y)&&W(m.prev,m,m.next)>=0)return!1;m=m.nextZ}return!0}function Oe(n,t,e,i){const r=ft.create(n,t,e);return i?(r.next=i.next,r.prev=i,i.next.prev=r,i.next=r):(r.prev=r,r.next=r),r}function Mt(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)}function Zr(n){let t=n,e=n;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==n);return e}function Nr(n,t,e,i,r,s){const a=new Array;for(let o=0,l=i.length;o<l;o++){const h=ui(n,t,e,i[o]*s,o<l-1?i[o+1]*s:e*s,s,!1);h===h.next&&(h.steiner=!0),a.push(Zr(h))}a.sort(jr);for(const o of a)Xr(o,r),r=yt(r,r.next);return r}function Xr(n,t){if(t=Ur(n,t)){const e=di(t,n);yt(e,e.next)}}function Ur(n,t){let e=t;const i=n.x,r=n.y;let s,a=-1/0;do{if(r<=e.y&&r>=e.next.y&&e.next.y!==e.y){const _=e.x+(r-e.y)*(e.next.x-e.x)/(e.next.y-e.y);if(_<=i&&_>a){if(a=_,_===i){if(r===e.y)return e;if(r===e.next.y)return e.next}s=e.x<e.next.x?e:e.next}}e=e.next}while(e!==t);if(!s)return null;if(i===a)return s.prev;const o=s,l=s.x,h=s.y;let u,c=1/0;for(e=s.next;e!==o;)i>=e.x&&e.x>=l&&i!==e.x&&ht(r<h?i:a,r,l,h,r<h?a:i,r,e.x,e.y)&&(u=Math.abs(r-e.y)/(i-e.x),(u<c||u===c&&e.x>s.x)&&vt(e,n)&&(s=e,c=u)),e=e.next;return s}function fi(n,t,e,i){for(let r;r!==n;r=r.next){if(r=r||n,r.z===null&&(r.z=qt(r.x,r.y,t,e,i)),r.prev.next!==r||r.next.prev!==r)return r.prev.next=r,r.next.prev=r,fi(n,t,e,i);r.prevZ=r.prev,r.nextZ=r.next}return n.prevZ.nextZ=null,n.prevZ=null,Yr(n)}function Yr(n){let t,e=1;for(;;){let i,r=n;n=null,t=null;let s=0;for(;r;){s++,i=r;let a=0;for(;a<e&&i;a++)i=i.nextZ;let o=e;for(;a>0||o>0&&i;){let l;a===0?(l=i,i=i.nextZ,o--):o!==0&&i?r.z<=i.z?(l=r,r=r.nextZ,a--):(l=i,i=i.nextZ,o--):(l=r,r=r.nextZ,a--),t?t.nextZ=l:n=l,l.prevZ=t,t=l}r=i}if(t.nextZ=null,e*=2,s<2)return n}}function W(n,t,e){return(t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y)}function _i(n,t,e,i){return!!(tt(n,t)&&tt(e,i)||tt(n,i)&&tt(e,t))||W(n,t,e)>0!=W(n,t,i)>0&&W(e,i,n)>0!=W(e,i,t)>0}function qr(n,t){let e=n;do{if(e.index!==n.index&&e.next.index!==n.index&&e.index!==t.index&&e.next.index!==t.index&&_i(e,e.next,n,t))return!0;e=e.next}while(e!==n);return!1}function Hr(n,t,e,i,r,s){let a=0;for(let o=i,l=r-s;o<r;o+=s)a+=(n[l+t*s]-n[o+t*s])*(n[o+1+t*s]+n[l+1+t*s]),l=o;return a}function ht(n,t,e,i,r,s,a,o){return(r-a)*(t-o)-(n-a)*(s-o)>=0&&(n-a)*(i-o)-(e-a)*(t-o)>=0&&(e-a)*(s-o)-(r-a)*(i-o)>=0}function vt(n,t){return W(n.prev,n,n.next)<0?W(n,t,n.next)>=0&&W(n,n.prev,t)>=0:W(n,t,n.prev)<0||W(n,n.next,t)<0}function qt(n,t,e,i,r){return(n=1431655765&((n=858993459&((n=252645135&((n=16711935&((n=32767*(n-e)*r)|n<<8))|n<<4))|n<<2))|n<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-i)*r)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function tt(n,t){return n.x===t.x&&n.y===t.y}function jr(n,t){return n.x-t.x}function Qr(n,t,e,i){let r=n;do{const s=r.prev,a=r.next.next;!tt(s,a)&&_i(s,r,r.next,a)&&vt(s,a)&&vt(a,s)&&(t.push(s.index/e+i),t.push(r.index/e+i),t.push(a.index/e+i),Mt(r),Mt(r.next),r=n=a),r=r.next}while(r!==n);return r}function Jr(n,t,e,i,r,s,a){let o=n;do{let l=o.next.next;for(;l!==o.prev;){if(o.index!==l.index&&ts(o,l)){let h=di(o,l);return o=yt(o,o.next),h=yt(h,h.next),gt(o,t,e,i,r,s,a,0),void gt(h,t,e,i,r,s,a,0)}l=l.next}o=o.next}while(o!==n)}function ts(n,t){return n.next.index!==t.index&&n.prev.index!==t.index&&!qr(n,t)&&vt(n,t)&&vt(t,n)&&es(n,t)}function es(n,t){let e=n,i=!1;const r=(n.x+t.x)/2,s=(n.y+t.y)/2;do e.y>s!=e.next.y>s&&e.next.y!==e.y&&r<(e.next.x-e.x)*(s-e.y)/(e.next.y-e.y)+e.x&&(i=!i),e=e.next;while(e!==n);return i}function di(n,t){const e=ft.create(n.index,n.x,n.y),i=ft.create(t.index,t.x,t.y),r=n.next,s=t.prev;return n.next=t,t.prev=n,e.next=r,r.prev=e,i.next=e,e.prev=i,s.next=i,i.prev=s,i}class ft{constructor(){this.index=0,this.x=0,this.y=0,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}static create(t,e,i){const r=jt<Ht.length?Ht[jt++]:new ft;return r.index=t,r.x=e,r.y=i,r.prev=null,r.next=null,r.z=null,r.prevZ=null,r.nextZ=null,r.steiner=!1,r}}const Ht=new Array,is=8096;let jt=0;for(let n=0;n<is;n++)Ht.push(new ft);const rs=1e-5,J=new ei(0,0,0,1,0),Qt=new ei(0,0,0,1,0);function Ge(n,t,e){let i=0;for(let r=1;r<e;r++){const s=n[2*(t+r-1)],a=n[2*(t+r-1)+1];i+=(n[2*(t+r)]-s)*(n[2*(t+r)+1]+a)}return i}function ss(n,t,e,i,r){let s=0;const a=2;for(let o=e;o<i;o+=3){const l=(n[o]-r)*a,h=(n[o+1]-r)*a,u=(n[o+2]-r)*a;s+=Math.abs((t[l]-t[u])*(t[h+1]-t[l+1])-(t[l]-t[h])*(t[u+1]-t[l+1]))}return s}function ns(n,t){const{coords:e,lengths:i,hasIndeterminateRingOrder:r}=t,s=0,a=n;if(r)return!1;let o=0;for(let l=0;l<i.length;){let h=l,u=i[l],c=Ge(e,o,u);const _=[];for(;++h<i.length;){const p=i[h],x=Ge(e,o+u,p);if(!(x>0))break;c+=x,_.push(o+u),u+=p}const d=a.length;Or(a,e,o,o+u,_,2,s);const m=ss(a,e,d,a.length,s),f=Math.abs(c);if(Math.abs((m-f)/Math.max(1e-7,f))>rs)return a.length=0,!1;l=h,o+=u}return!0}function as(n){const{coords:t,lengths:e}=n,{buffer:i}=or(t,e);return i}function os(n,t,e){let i=0;for(let r=0;r<n.lengths.length;r++){const s=n.lengths[r];for(let a=0;a<s;a++){const o=n.coords[2*(a+i)],l=n.coords[2*(a+i)+1];if(o<t||o>e||l<t||l>e)return!0}i+=s}return!1}function ls(n,t){if(V(n))return null;if(!os(n,-128,ct+128))return n;J.setPixelMargin(t),J.reset(ni.Polygon);let e=0;for(let a=0;a<n.lengths.length;a++){const o=n.lengths[a];let l=n.coords[2*(0+e)],h=n.coords[2*(0+e)+1];J.moveTo(l,h);for(let u=1;u<o;u++)l=n.coords[2*(u+e)],h=n.coords[2*(u+e)+1],J.lineTo(l,h);J.close(),e+=o}const i=J.result(!1);if(!i)return null;const r=[],s=[];for(const a of i){let o=0;for(const l of a)s.push(l.x),s.push(l.y),o++;r.push(o)}return new Ci(r,s)}function hs(n,t){Qt.setPixelMargin(t);const e=Qt,i=-t,r=ct+t;let s=[],a=!1,o=0;for(;o<n.length;){const l=[],h=n[o];if(!h)return null;e.reset(ni.LineString);let[u,c]=h[0];if(a)e.moveTo(u,c);else{if(u<i||u>r||c<i||c>r){a=!0;continue}l.push({x:u,y:c})}let _=!1;const d=h.length;for(let m=1;m<d;++m)if(u+=h[m][0],c+=h[m][1],a)e.lineTo(u,c);else{if(u<i||u>r||c<i||c>r){_=!0;break}l.push({x:u,y:c})}if(_)a=!0;else{if(a){const m=e.resultWithStarts();if(m)for(const f of m)s.push(f)}else s.push({line:l,start:0});o++,a=!1}}return s=s.filter(l=>l.line.length>1),s.length===0?null:s}J.setExtent(ct),Qt.setExtent(ct);const kt=8,A=16,Ke=65535,mi=n=>class extends n{constructor(...t){super(...t),this.tessellationProperties={},this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0},this.geometryType=P.LINE}writeGeometry(t,e,i,r){this._writeGeometry(t,e,i,r)}_initializeTessellator(t){const e=Rt.load(this._materialKey),i=xt.load(this._materialKey),r=this._tessellationOptions,s=e.vvSizeFieldStops||e.vvSizeMinMaxValue||e.vvSizeScaleStops||e.vvSizeUnitValue,a=this.tessellationProperties._halfWidth<Ji&&!t&&!s;this.tessellationProperties.minMaxZoom=this._minMaxZoom,r.wrapDistance=Ke,r.textured=this._isDashed||this._hasPattern,r.offset=this.tessellationProperties.offset,r.halfWidth=this.tessellationProperties._halfWidth;const o=a?0:1,l=i.outlinedFill?us:cs;this._lineTessellator=new lr(l(this.tessellationProperties,o,o),fs(this.tessellationProperties),a)}_write(t,e,i,r){const s=e.geometryType==="esriGeometryPoint";t.recordStart(e.getDisplayId(),this._materialKey,this.geometryType,s),this._writeGeometry(t,e,r,s),t.recordEnd()}_writeGeometry(t,e,i,r){const s=i!=null?i:e.readLegacyGeometryForDisplay(),a=this._getLines(s,r);V(a)||this._writeVertices(t,e,a)}_getLines(t,e){if(V(t))return null;const i=t.paths||t.rings;return V(i)?null:hs(i,e?256:16)}_writeVertices(t,e,i){const r=e.getDisplayId(),s=t.vertexCount(),a=this.tessellationProperties,o=this._tessellationOptions;a.out=t,a.id=r,a.indexCount=0,a.vertexCount=0,a.offset=s,o.capType=this._capType,o.joinType=this._joinType;const l=xt.load(this._materialKey);this.tessellationProperties.key=l.outlinedFill?l:Rt.load(this._materialKey);for(const{line:h,start:u}of i)o.initialDistance=u%Ke,this._lineTessellator.tessellate(h,o)}},cs=(n,t,e)=>(i,r,s,a,o,l,h,u,c,_,d)=>{const m=M(d,Math.ceil(A*n._halfWidth)),f=C(Math.round(A*h),Math.round(A*u),Math.round(A*c),Math.round(A*_)),p=C(A*o,A*l,0,n._bitset),x=n.out;return x.vertexBounds(i,r,t,e),x.vertexWrite(M(kt*i,kt*r)),x.vertexWrite(n.id),x.vertexWrite(n._fillColor),x.vertexWrite(f),x.vertexWrite(m),x.vertexWrite(n._tl),x.vertexWrite(n._br),x.vertexWrite(p),x.vertexWrite(M(Math.ceil(A*n._halfReferenceWidth),0)),x.vertexWrite(n.minMaxZoom),x.vertexEnd(),n.offset+n.vertexCount++},us=(n,t,e)=>(i,r,s,a,o,l,h,u,c,_,d)=>{const m=C(0,0,A*n._halfWidth,A*n._halfReferenceWidth),f=C(A*h+128,A*u+128,A*c+128,A*_+128),p=n.out,x=n._bitset<<24|n.id;return p.vertexBounds(i,r,t,e),p.vertexWrite(M(kt*i,kt*r)),p.vertexWrite(x),p.vertexWrite(n._fillColor),n.key.simple||(p.vertexWrite(0),p.vertexWrite(0)),p.vertexWrite(m),p.vertexWrite(f),n.key.simple||p.vertexWrite(n.minMaxZoom),p.vertexEnd(),n.offset+n.vertexCount++},fs=n=>(t,e,i)=>{const r=n.out;r.indexWrite(t),r.indexWrite(e),r.indexWrite(i),n.indexCount+=3},_s=_t.getLogger("esri.views.2d.engine.webgl.WGLLineTemplate");class X extends mi(wt){constructor(t,e,i,r,s,a,o,l,h,u,c,_,d,m,f,p,x,y,v){super();const w=Rt.load(t);e&&(w.sdf=e.sdf,w.pattern=!0,w.textureBinding=e.textureBinding),this._capType=r,this._joinType=s,this._miterLimitCosine=Yt(a),this.tessellationProperties._fillColor=o,this.tessellationProperties._tl=l,this.tessellationProperties._br=h,this._hasPattern=u,this._isDashed=c,this._zOrder=p,this._effects=x,this._minMaxZoom=M(Math.round(y*E),Math.round(v*E)),this._materialKey=w.data;const S=(d?lt:0)|(m?tr:0)|(_?er:0);this.tessellationProperties._bitset=S,this.tessellationProperties._halfWidth=.5*i,this.tessellationProperties._halfReferenceWidth=.5*f,this.tessellationProperties.offset=0,this._initializeTessellator(!1)}static fromCIMLine(t,e,i){const r=t.color,s=t.scaleFactor||1,a=!!t.dashTemplate;let o=t.cap;a&&o===ze.ROUND&&(o=ze.SQUARE);const l=t.join,h=g(t.width)*s,u=g(t.referenceWidth),c=g(t.miterLimit),_=r&&I(r)||0,[d,m]=H(t.scaleInfo,i),f=!1;if(!e)return new X(t.materialKey,e,h,o,l,c,_,0,0,!1,a,t.scaleDash,t.colorLocked,f,u,t.zOrder,t.effects,d,m);const{rect:p,width:x,height:y}=e,v=p.x+$,w=p.y+$,S=v+x,L=w+y,z=M(v,w),T=M(S,L),rt=!1;return new X(t.materialKey,e,h,o,l,c,_,z,T,!0,a,t.scaleDash,t.colorLocked,rt,u,t.zOrder,t.effects,d,m)}static fromFillOutline(t){var e;return t.isOutlinedFill&&t.outline&&((e=t.outline)==null?void 0:e.style)==="esriSLSSolid"?X.fromSimpleLine(nt({hash:"",materialKey:t.materialKey},t.outline),null,!0):null}static fromSimpleLine(t,e,i=!1){const{color:r}=t,s=t.style!=="esriSLSSolid"&&t.style!=="esriSLSNull",a=sr(t.cap||"round"),o=nr(t.join||"round");let l=r&&t.style!=="esriSLSNull"&&Y(r)||0;t.style==="esriSLSNull"&&(l=0);const h=g(t.width),u=t.miterLimit;if(!e)return new X(t.materialKey,e,h,a,o,u,l,0,0,!1,s,!0,!1,i,h,0,null,K,Z);const{rect:c,width:_,height:d}=e,m=c.x+$,f=c.y+$,p=m+_,x=f+d,y=M(m,f),v=M(p,x);return new X(t.materialKey,e,h,a,o,u,l,y,v,!0,s,!0,!1,i,h,0,null,K,Z)}static fromPictureLineSymbol(t,e,i,r){return _s.error("PictureLineSymbol support does not exist!"),null}}const ds=100,Ze=1,pi=n=>class extends n{constructor(...t){super(...t),this.forceLibtess=!1,this._bitset=0,this._lineTemplate=null,this.geometryType=P.FILL}_maybeAddLineTemplate(t){this._lineTemplate=X.fromFillOutline(t)}_write(t,e,i,r){const s=e.geometryType==="esriGeometryPoint",a=xt.load(this._materialKey);t.recordStart(e.getDisplayId(),this._materialKey,this.geometryType,s),this._writeGeometry(t,e,a,r,s),a.outlinedFill&&F(this._lineTemplate)&&this._lineTemplate.writeGeometry(t,e,r,s),t.recordEnd()}_writeGeometry(t,e,i,r,s){const a=this._getGeometry(e,r,s);if(V(a))return;const o=[];if(!(a.maxLength>ds)&&!this.forceLibtess&&ns(o,a))return void(o.length&&this._writeVertices(t,e,a.coords,a.lengths,i,o));const l=as(a);this._writeVertices(t,e,l,[l.length/2],i)}_writeVertex(t,e,i,r,s,a){const o=M(Ze*r,Ze*s);t.vertexBounds(r,s,0,0),t.vertexWrite(o),t.vertexWrite(e),i.dotDensity?t.vertexWriteF32(1/Math.abs(a.readGeometryArea())):(t.vertexWrite(this.fillColor),i.simple||(t.vertexWrite(this.tl),t.vertexWrite(this.br)),t.vertexWrite(this.aux2),t.vertexWrite(this.aux3),i.simple||t.vertexWrite(this._minMaxZoom))}_writeVertices(t,e,i,r,s,a){const o=e.getDisplayId(),l=this._bitset<<24|o,h=r.reduce((d,m)=>d+m),u=s.dotDensity?4:10,c=t.vertexCount();t.vertexEnsureSize(u*h);let _=0;if(a)for(const d of a){const m=i[2*d],f=i[2*d+1];this._writeVertex(t,l,s,m,f,e),_++}else for(let d=0;d<i.length;d+=2){const m=Math.round(i[d]),f=Math.round(i[d+1]);this._writeVertex(t,l,s,m,f,e),_++}t.indexEnsureSize(_);for(let d=0;d<_;d++)t.indexWrite(d+c)}_getGeometry(t,e,i){const r=e?te(ee(e),2):t.readGeometryForDisplay();return r?ls(r,i?256:8):null}},Ne=_t.getLogger("esri.views.2d.engine.webgl.WGLDynamicMeshTemplate");class Gt extends wt{constructor(t){super(),this._ongoingMaterialRequestMap=new Map,this._materialCache=new Map,this._dynamicPropertyMap=new Map,this._cimLayer=t}analyze(t,e,i,r,s){if(s&&s.length===0)return null;const a=s&&s.length>0,o=e.readLegacyFeature(),l=this._materialCache,h=this._cimLayer.materialHash;if(!h)return Ne.error("A Dynamic mesh template must have a material hash value or function!"),Promise.reject(null);const u=typeof h=="function"?h(o,i,r):h;if(l.has(u)){const y=l.get(u);return Promise.resolve(y)}const c=this._ongoingMaterialRequestMap.get(u);if(c)return c;const _=this._cimLayer,d=Mr(_.cim,this._cimLayer.materialOverrides);d.mosaicHash=u;const{type:m,url:f}=_,p={cim:d,type:m,mosaicHash:u,url:f,size:null,dashTemplate:null,text:null,fontName:null};switch(m){case"marker":p.size=Kt(_.size,o,i,r);break;case"line":p.dashTemplate=_.dashTemplate;break;case"text":p.text=Kt(_.text,o,i,r),p.fontName=Kt(_.fontName,o,i,r)}const x=t.getMosaicItem(p,s).then(y=>(a||(this._ongoingMaterialRequestMap.delete(u),l.set(u,y)),y)).catch(y=>(this._ongoingMaterialRequestMap.delete(u),Ne.error(".analyze()",y.message),null));return a||this._ongoingMaterialRequestMap.set(u,x),x}}const Ct=128;class ue extends pi(Gt){constructor(t,e,i){var r;if(super(t),this._minMaxZoom=M(Math.round(e*E),Math.round(i*E)),b(t.color)){const c=(_,d,m)=>{const f=t.color(_,d,m);return f&&I(f)||0};this._dynamicPropertyMap.set("fillColor",c)}else{const c=t.color;this.fillColor=c&&I(c)||0}const s=((r=t.cim.placement)==null?void 0:r.type)==="CIMMarkerPlacementInsidePolygon"&&t.cim.placement.shiftOddRows?2:1,a=t.height;if(b(a)){const c=(_,d,m)=>a(_,d,m)*s;this._dynamicPropertyMap.set("_height",c)}else this._height=(a||0)*s;const o=t.offsetX;if(b(o)){const c=(_,d,m)=>{let f=g(o(_,d,m))+Ct;return f>255?f=255:f<0&&(f=0),f};this._dynamicPropertyMap.set("_offsetX",c)}else{let c=g(o||0)+Ct;c>255?c=255:c<0&&(c=0),this._offsetX=c}const l=t.offsetY;if(b(l)){const c=(_,d,m)=>{let f=g(-l(_,d,m))+Ct;return f>255?f=255:f<0&&(f=0),f};this._dynamicPropertyMap.set("_offsetY",c)}else{let c=g(-l||0)+Ct;c>255?c=255:c<0&&(c=0),this._offsetY=c}const h=t.scaleX;b(h)?this._dynamicPropertyMap.set("_scaleX",h):this._scaleX=h||1;const u=t.angle;if(b(u)){const c=(_,d,m)=>$e(u(_,d,m));this._dynamicPropertyMap.set("_angle",c)}else this._angle=$e(u)||0;if(F(t.effects)){const c=t.effects;b(c)?this._dynamicPropertyMap.set("_effects",c):this._effects=c}this._cimFillLayer=t,this._fillMaterialKey=xt.load(t.materialKey)}static fromCIMFill(t,e){const[i,r]=H(t.scaleInfo,e);return new ue(t,i,r)}bindFeature(t,e,i){const r=t.readLegacyFeature();this._dynamicPropertyMap.forEach((u,c)=>{this[c]=u(r,e,i)});const s=this._fillMaterialKey,a=this._materialCache,o=(0,this._cimFillLayer.materialHash)(r,e,i),l=a.get(o);let h=null;if(l&&k(l.spriteMosaicItem)&&(h=l.spriteMosaicItem),h){const{rect:u,width:c,height:_}=h,d=u.x+$,m=u.y+$,f=d+c,p=m+_;let x=Math.round(g(this._height));x>255?x=255:x<=0&&(x=p-m);let y=Math.round(g(this._height/_*c||0));y>255?y=255:y<=0&&(y=f-d);const v=this._scaleX,w=1;this.tl=M(d,m),this.br=M(f,p),this.aux2=C(y,x,this._offsetX,this._offsetY),this.aux3=C(v,w,this._angle,0),s.sdf=h.sdf,s.pattern=!0,s.textureBinding=h.textureBinding}else this.tl=0,this.br=0,this.aux2=0,this.aux3=0,s.sdf=!1,s.pattern=!1,s.textureBinding=0;this._materialKey=s.data}}class fe extends mi(Gt){constructor(t,e,i){super(t),this._minMaxZoom=M(Math.round(e*E),Math.round(i*E)),this._cimLineLayer=t;let r=0;b(t.width)||(r=.5*g(t.width));const s=(l,h,u)=>b(t.width)?.5*g(t.width(l,h,u)):r;this._dynamicPropertyMap.set("_halfWidth",s),b(t.cap)?this._dynamicPropertyMap.set("_capType",t.cap):this._capType=t.cap,b(t.join)?this._dynamicPropertyMap.set("_joinType",t.join):this._joinType=t.join;const a=t.color;if(b(a)){const l=(h,u,c)=>I(a(h,u,c));this._dynamicPropertyMap.set("_fillColor",l)}else this._fillColor=a&&I(a)||0;const o=t.miterLimit;if(b(o)){const l=(h,u,c)=>Yt(o(h,u,c));this._dynamicPropertyMap.set("_miterLimitCosine",l)}else this._miterLimitCosine=Yt(o);if(F(t.effects)){const l=t.effects;b(l)?this._dynamicPropertyMap.set("_effects",l):this._effects=l}this._scaleFactor=t.scaleFactor||1,this._isDashed=t.dashTemplate!=null,this.tessellationProperties._bitset=(t.colorLocked?1:0)|(t.scaleDash?1:0)<<1,this._materialKey=t.materialKey,this._initializeTessellator(!0)}static fromCIMLine(t,e){const[i,r]=H(t.scaleInfo,e);return new fe(t,i,r)}bindFeature(t,e,i){const r=t.readLegacyFeature();this._dynamicPropertyMap.forEach((u,c)=>{this[c]=u(r,e,i)}),this._halfWidth*=this._scaleFactor;const s=this._materialCache,a=(0,this._cimLineLayer.materialHash)(r,e,i),o=s.get(a);let l=null;if(o&&k(o.spriteMosaicItem)&&(l=o.spriteMosaicItem),l){this._hasPattern=!0;const{rect:u,width:c,height:_}=l,d=u.x+$,m=u.y+$,f=d+c,p=m+_;this.tessellationProperties._tl=M(d,m),this.tessellationProperties._br=M(f,p)}else this._hasPattern=!1,this.tessellationProperties._tl=0,this.tessellationProperties._br=0;this.tessellationProperties._fillColor=this._fillColor,this.tessellationProperties._halfWidth=this._halfWidth,this.tessellationProperties.offset=0,this.tessellationProperties._halfReferenceWidth=this.tessellationProperties._halfWidth;const h=Rt.load(this._materialKey);l&&(h.sdf=l.sdf,h.pattern=!0,h.textureBinding=l.textureBinding),this._materialKey=h.data}}const ms=se(),ps=re(),xs=_t.getLogger("esri.views.2d.engine.webgl.WGLDynamicMarkerTemplate");class _e extends ci(Gt){constructor(t,e,i){super(t),this._cimMarkerLayer=t,this._minMaxZoom=M(Math.round(e*E),Math.round(i*E));const r=t.color;if(b(r)){const _=(d,m,f)=>I(r(d,m,f));this._dynamicPropertyMap.set("_fillColor",_)}else this._fillColor=I(r);const s=t.outlineColor;if(b(s)){const _=(d,m,f)=>I(s(d,m,f));this._dynamicPropertyMap.set("_outlineColor",_)}else this._outlineColor=I(s);const a=t.size;if(b(a)){const _=(d,m,f)=>g(a(d,m,f));this._dynamicPropertyMap.set("_size",_)}else this._size=g(a)||0;const o=t.scaleX;b(o)?this._dynamicPropertyMap.set("_scaleX",o):this._scaleX=o||1;const l=t.offsetX;if(b(l)){const _=(d,m,f)=>g(l(d,m,f));this._dynamicPropertyMap.set("xOffset",_)}else this.xOffset=g(l)||0;const h=t.offsetY;if(b(h)){const _=(d,m,f)=>g(h(d,m,f));this._dynamicPropertyMap.set("yOffset",_)}else this.yOffset=g(h)||0;const u=t.outlineWidth;if(b(u)){const _=(d,m,f)=>g(u(d,m,f));this._dynamicPropertyMap.set("_outlineWidth",_)}else this._outlineWidth=g(u)||0;const c=t.rotation;if(b(c)?this._dynamicPropertyMap.set("_angle",c):this._angle=c||0,F(t.effects)){const _=t.effects;b(_)?this._dynamicPropertyMap.set("_effects",_):this._effects=_}if(F(t.markerPlacement)){const _=t.markerPlacement;b(_)?this._dynamicPropertyMap.set("_markerPlacement",_):this._markerPlacement=_}this._scaleFactor=He(t.scaleFactor,1),this._bitSet=(t.alignment===B.MAP?1:0)|(t.colorLocked?1:0)<<1|(t.scaleSymbolsProportionally?1:0)<<3,this._materialKey=t.materialKey}static fromCIMMarker(t,e){const[i,r]=H(t.scaleInfo,e);return new _e(t,i,r)}bindFeature(t,e,i){const r=t.readLegacyFeature();this._dynamicPropertyMap.forEach((Q,st)=>{this[st]=Q(r,e,i)});const s=this._cimMarkerLayer.materialHash,a=typeof s=="function"?s(r,e,i):s,o=this._materialCache.get(a);if(!o||!k(o.spriteMosaicItem)||!o.spriteMosaicItem)return void xs.error(new et("mapview-cim","Encountered an error when binding feature"));const l=o.spriteMosaicItem,h=this._cimMarkerLayer.sizeRatio,u=l.width/l.height*this._scaleX,c=this._cimMarkerLayer.rotateClockwise?this._angle:-this._angle;let _=this._size,d=_*u;const m=this.xOffset,f=this.yOffset;this.xOffset*=this._scaleFactor,this.yOffset*=this._scaleFactor;const p=this._cimMarkerLayer.scaleSymbolsProportionally&&this._cimMarkerLayer.frameHeight?this._size/g(this._cimMarkerLayer.frameHeight):1,x=this._outlineWidth*p,y=g(this._cimMarkerLayer.referenceSize);let v=0,w=0;const S=this._cimMarkerLayer.anchorPoint;S&&(this._cimMarkerLayer.isAbsoluteAnchorPoint?this._size&&(v=-S.x/(this._size*u),w=S.y/this._size):(v=S.x,w=S.y)),this._sizeOutlineWidth=C(Math.round(Math.min(Math.sqrt(128*d),255)),Math.round(Math.min(Math.sqrt(128*_),255)),Math.round(Math.min(Math.sqrt(128*x),255)),Math.round(Math.min(Math.sqrt(128*y),255))),this.angle=c;const L=Math.round(64*h);this._bitestAndDistRatio=M(this._bitSet,L);const z=l.rect.x+$,T=l.rect.y+$,rt=z+l.width,j=T+l.height;this._texUpperLeft=M(z,T),this._texUpperRight=M(rt,T),this._texBottomLeft=M(z,j),this._texBottomRight=M(rt,j);const D=si.load(this._materialKey);D.sdf=l.sdf,D.pattern=!0,D.textureBinding=l.textureBinding,this._materialKey=D.data,this._anchorX=.5-(.5+v)*l.width/l.width,this._anchorY=.5-(.5+w)*l.height/l.height,d*=h,_*=h,d*=this._scaleFactor,_*=this._scaleFactor,d*=l.rect.width/l.width,_*=l.rect.height/l.height,this._computedWidth=d,this._computedHeight=_,this._applyTransformation(ps,ms),this.xOffset=m,this.yOffset=f}}function xi(n){const t=new Array(n.length);for(let e=0;e<n.length;e++)t[e]=n.charCodeAt(e);return t}const Xe=5;function ys(n,t,e,i){return typeof n.text=="string"?n.text:typeof n.text=="function"?n.text(t,e,i):""}class de extends hi(Gt){constructor(t,e,i){super(t),this._horizontalAlignment="center",this._verticalAlignment="middle",this._textToGlyphs=new Map,this._minMaxZoom=M(Math.round(e*E),Math.round(i*E));const r=t.scaleFactor||1;this._cimTextLayer=t;const s=t.color;if(b(s)){const f=(p,x,y)=>I(s(p,x,y));this._dynamicPropertyMap.set("_color",f)}else this._color=I(s);const a=t.outlineColor;if(b(a)){const f=(p,x,y)=>I(a(p,x,y));this._dynamicPropertyMap.set("_haloColor",f)}else this._haloColor=I(a);let o;b(t.size)||(o=Math.min(Math.round(g(t.size*t.sizeRatio)),127));const l=(f,p,x)=>b(t.size)?Math.min(Math.round(g(t.size(f,p,x)*t.sizeRatio)),127):o;if(this._dynamicPropertyMap.set("_size",l),b(t.outlineSize)){const f=(p,x,y)=>Math.min(Math.floor(Xe*g(t.outlineSize(p,x,y)*t.sizeRatio)),127);this._dynamicPropertyMap.set("_haloSize",f)}else this._haloSize=Math.min(Math.floor(Xe*g(t.outlineSize*t.sizeRatio)),127);let h;b(t.offsetX)||(h=Math.round(g(t.offsetX*t.sizeRatio)));const u=(f,p,x)=>b(t.offsetX)?Math.round(g(t.offsetX(f,p,x)*t.sizeRatio)):h;let c;this._dynamicPropertyMap.set("_xOffset",u),b(t.offsetY)||(c=Math.round(g(t.offsetY*t.sizeRatio)));const _=(f,p,x)=>b(t.offsetY)?Math.round(g(t.offsetY(f,p,x)*t.sizeRatio)):c;if(this._dynamicPropertyMap.set("_yOffset",_),b(t.angle)?this._dynamicPropertyMap.set("_angle",t.angle):this._angle=t.angle,b(t.horizontalAlignment)?this._dynamicPropertyMap.set("_horizontalAlignment",t.horizontalAlignment):this._horizontalAlignment=t.horizontalAlignment,b(t.verticalAlignment)?this._dynamicPropertyMap.set("_verticalAlignment",t.verticalAlignment):this._verticalAlignment=t.verticalAlignment,F(t.effects)){const f=t.effects;b(f)?this._dynamicPropertyMap.set("_effects",f):this._effects=f}if(F(t.markerPlacement)){const f=t.markerPlacement;b(f)?this._dynamicPropertyMap.set("_markerPlacement",f):this._textPlacement=f}b(t.text)?this._dynamicPropertyMap.set("_text",t.text):this._text=t.text,this._scaleFactor=r;const d=Math.min(Math.round(g(t.referenceSize*t.sizeRatio)),127);this._referenceSize=Math.round(Math.sqrt(256*d)),this._materialKey=t.materialKey;const m=pr.load(this._materialKey);m.sdf=!0,this._bitset=(t.alignment===B.MAP?1:0)|(t.colorLocked?1:0)<<1,this._materialKey=m.data,this._decoration="none",this._lineHeight=1,this._lineWidth=512,this._isCIM=!0}static fromCIMText(t,e){const[i,r]=H(t.scaleInfo,e);return new de(t,i,r)}async analyze(t,e,i,r){const s=e.readLegacyFeature(),a=ys(this._cimTextLayer,s,i,r),o=await super.analyze(t,e,i,r,xi(a));return o&&o.glyphMosaicItems&&this._textToGlyphs.set(a,o.glyphMosaicItems),o}bindFeature(t,e,i){const r=t.readLegacyFeature();if(this._dynamicPropertyMap.forEach((a,o)=>{this[o]=a(r,e,i)}),!this._text||this._text.length===0)return void(this._shapingInfo=null);this._size*=this._scaleFactor,this._scale=this._size/Je,this._xOffset*=this._scaleFactor,this._yOffset*=this._scaleFactor,this._xAlignD=ii(this._horizontalAlignment||"center"),this._yAlignD=ri(this._verticalAlignment||"baseline");const s=this._textToGlyphs.get(this._text);this.bindTextInfo(s,!1)}}const O=128;class U extends pi(wt){constructor(t,e,i,r,s,a,o,l,h,u,c,_,d,m,f,p){super(),this._effects=m;const x=xt.load(t);e&&(x.sdf=e.sdf,x.pattern=!0,x.textureBinding=e.textureBinding),this.fillColor=i,this.tl=r,this.br=s,this.aux2=C(a,o,l,h),this.aux3=C(u,c,_,0),this._bitset=d,this._minMaxZoom=M(Math.round(f*E),Math.round(p*E)),this._materialKey=x.data}static fromCIMFill(t,e,i){const r=t.color,s=r&&I(r)||0,a=t.materialKey,[o,l]=H(t.scaleInfo,i);if(!e)return new U(a,null,s,0,0,0,0,0,0,0,0,0,t.colorLocked?lt:0,t.effects,o,l);const{rect:h,width:u,height:c}=e,_=t.scaleX||1,d=h.x+$,m=h.y+$,f=d+u,p=m+c,x=t.height,y=_*x;let v=Math.round(x);v>255?v=255:v<=0&&(v=p-m);let w=Math.round(y);w>255?w=255:w<=0&&(w=f-d);let S=g(t.offsetX||0)+O;S>255&&(S=255);let L=g(-t.offsetY||0)+O;L>255&&(L=255);const z=M(d,m),T=M(f,p);return new U(a,e,s,z,T,w,v,S,L,O,O,wr(t.angle),t.colorLocked?lt:0,t.effects,o,l)}static fromSimpleFill(t,e,i=!1){const{color:r}=t,s=r&&t.style!=="esriSFSNull"&&Y(r)||0,a=i?lt:0,o=t.materialKey;let l;if(e){const{rect:h,width:u,height:c}=e,_=h.x+$,d=h.y+$,m=_+u,f=d+c,p=M(_,d),x=M(m,f);l=new U(o,e,s,p,x,u,c,0,0,O,O,0,a,null,K,Z)}else l=new U(o,null,s,0,0,0,0,0,0,0,0,0,a,null,K,Z);return l._maybeAddLineTemplate(t),l}static fromPictureFill(t,e,i=!1){const r=ti,{rect:s,width:a,height:o}=e,l=s.x+$,h=s.y+$,u=l+a,c=h+o,_=M(l,h),d=M(u,c);let m=Math.round(g(t.width));m>255&&(m=255);let f=Math.round(g(t.height));f>255&&(f=255);let p=g(t.xoffset)+O;p>255&&(p=255);let x=g(-t.yoffset)+O;x>255&&(x=255);const y=t.materialKey,v=i?lt:0,w=new U(y,e,r,_,d,m,f,p,x,O*t.xscale,O*t.yscale,0,v,null,K,Z);return w._maybeAddLineTemplate(t),w}}class gs{constructor(){this._resolver=null}isHeld(){return!!this._resolver}async acquire(){if(!this._resolver)return this._resolver=Ei(),Promise.resolve();await this._resolver.promise,await this.acquire()}release(){const t=this._resolver;this._resolver=null,t.resolve()}}async function Ms(n,t,e){try{await n.acquire(),await t(e),n.release()}catch(i){throw n.release(),i}}async function vs(n,t,e){if(!n.name)return Promise.reject(new et("style-symbol-reference-name-missing","Missing name in style symbol reference"));if(n.styleName&&n.styleName==="Esri2DPointSymbolsStyle")return ws(n,e);try{return bs(await Ri(n,t,e),n.name,t,e)}catch(i){return ne(i),null}}async function ws(n,t){const e=Ai.replace(/\{SymbolName\}/gi,n.name);try{const i=await je(e,t);return Qe(i.data)}catch(i){return ne(i),null}}async function bs(n,t,e,i){const r=n.data,s={portal:e&&e.portal||Fi.getDefault(),url:ki(n.baseUrl),origin:"portal-item"},a=r.items.find(l=>l.name===t);if(!a)throw new et("symbolstyleutils:symbol-name-not-found",`The symbol name '${t}' could not be found`,{symbolName:t});let o=Bi(Vi(a,"cimRef"),s);Di()&&(o=Oi(o));try{const l=await je(o,i);return Qe(l.data)}catch(l){return ne(l),null}}const Ue=async(n,t,e)=>new br(await vr(n.data,t,e),n.data,n.rendererKey,n.maxVVSize),q=async(n,t,e,i)=>{if(!n)return null;if(n.type==="cim")return Ue(n,t,e);if(n.type==="web-style"){const r={type:"cim",data:await vs(n,null,i),rendererKey:n.rendererKey,maxVVSize:n.maxVVSize};return Ue(r,t,e)}return n};function Et(n){if(!n)return null;const{type:t,cim:e,url:i,materialHash:r}=n,s={cim:e,type:t,mosaicHash:r,url:i,size:null,dashTemplate:null,path:null,text:null,fontName:null};switch(t){case"marker":s.size=n.size,s.path=n.path;break;case"line":s.dashTemplate=n.dashTemplate;break;case"text":s.text=n.text,s.fontName=n.fontName}return s}const R=_t.getLogger("esri.views.2d.engine.webgl.mesh.templates.WGLTemplateStore"),Ye=new Array,me={isOutline:!1,isOutlinedFill:!1,placement:null,stride:{fill:"default"},vvFlags:0},Ss=dt(nt({},we),{hash:JSON.stringify(we),materialKey:ae(P.MARKER,me)}),Ls=dt(nt({},be),{hash:JSON.stringify(be),materialKey:ae(P.LINE,me)}),Ps=dt(nt({},Se),{hash:JSON.stringify(Se),materialKey:ae(P.FILL,me)});function N(n,t){const e=n.length;return n.push(null),t.then(i=>n[e]=i),n}function pt(n){return!!(1&n)}function zs(n){return n.name==="worker:port-closed"}class qs{constructor(t,e){this._idCounter=1,this._templateIdCounter=1,this._idToTemplateGroup=new Map,this._symbolToTemplate=new Map,this._fetchQueue=[],this._idToResolver=new Map,this._cimTemplateCache=new Map,this._cimAnalyses=[],this._lock=new gs,this._fetchResource=t,this._tileInfo=e}get _markerError(){return this._errorTemplates.marker[0]}get _fillError(){return this._errorTemplates.fill[0]}get _lineError(){return this._errorTemplates.line[0]}get _textError(){return this._errorTemplates.line[0]}createTemplateGroup(t,e){this._initErrorTemplates();const i=t.hash;if(this._symbolToTemplate.has(i))return this._symbolToTemplate.get(i);const r=new Array;e&&this._createMeshTemplates(r,e,!0),this._createMeshTemplates(r,t,!1);const s=this._createGroupId(t.type==="expanded-cim"&&Ts(t));return this._idToTemplateGroup.set(s,r),this._symbolToTemplate.set(i,s),s}getTemplateGroup(t){return this._idToTemplateGroup.has(t)?this._idToTemplateGroup.get(t):Ye}getDynamicTemplateGroup(t){return this._idToTemplateGroup.has(t)?(pt(t)||R.error("mapview-template-store",`Id ${t} does not refer to a dynamic template`),this._idToTemplateGroup.get(t)):Ye}getMosaicItem(t,e){const i=this._createTemplateId(),r=new Promise(s=>this._idToResolver.set(i,s));return this._fetchQueue.push({symbol:t,id:i,glyphIds:e}),r}finalize(t){return this._fetchQueue.length||this._lock.isHeld()?Ms(this._lock,this._fetchAllQueuedResources.bind(this),t):Promise.resolve()}_initErrorTemplates(){this._errorTemplates||(this._errorTemplates={fill:this._createMeshTemplates([],Ps,!1),marker:this._createMeshTemplates([],Ss,!1),line:this._createMeshTemplates([],Ls,!1)})}_fetchAllQueuedResources(t){if(!this._fetchQueue.length)return Promise.resolve();const e=this._fetchQueue,i=this._cimAnalyses;return this._fetchQueue=[],this._cimAnalyses=[],Promise.all(i).then(()=>this._fetchResource(e,t).then(r=>{for(const{id:s,mosaicItem:a}of r)this._idToResolver.get(s)(a),this._idToResolver.delete(s)})).catch(r=>{Gi(r)?this._fetchQueue=this._fetchQueue.concat(e):zs(r)||R.error(new et("mapview-template-store","Unable to fetch requested texture resources",r))})}_createGroupId(t){return this._idCounter++<<1|(t?1:0)}_createTemplateId(){return this._templateIdCounter++}async _createSMS(t){const{spriteMosaicItem:e}=await this.getMosaicItem(t);return k(e,R)?G.fromSimpleMarker(t,e):this._markerError}async _createPMS(t){const{spriteMosaicItem:e}=await this.getMosaicItem(t);return k(e,R)?G.fromPictureMarker(t,e):this._markerError}async _createSFS(t,e){const{spriteMosaicItem:i}=await this.getMosaicItem(t);return k(i,R)?U.fromSimpleFill(t,i,e):this._fillError}async _createPFS(t,e){const{spriteMosaicItem:i}=await this.getMosaicItem(t);return k(i,R)?U.fromPictureFill(t,i,e):this._fillError}async _createSLS(t,e){const{spriteMosaicItem:i}=await this.getMosaicItem(t);return k(i,R)?X.fromSimpleLine(t,i):this._lineError}async _createLMS(t){const{spriteMosaicItem:e}=await this.getMosaicItem(t);return k(e,R)?G.fromLineSymbolMarker(t,e):this._markerError}async _createTS(t){const{glyphMosaicItems:e}=await this.getMosaicItem(t);return ut.fromText(t,e)}async _createCIMText(t){const{glyphMosaicItems:e}=await this.getMosaicItem(Et(t),xi(t.text));return k(e,R)?ut.fromCIMText(t,e,this._tileInfo):this._textError}async _createCIMFill(t){const{spriteMosaicItem:e}=await this.getMosaicItem(Et(t));return k(e,R)?U.fromCIMFill(t,e,this._tileInfo):this._fillError}async _createCIMLine(t){const{spriteMosaicItem:e}=await this.getMosaicItem(Et(t));return k(e,R)?X.fromCIMLine(t,e,this._tileInfo):this._lineError}async _createCIMMarker(t){const{spriteMosaicItem:e}=await this.getMosaicItem(Et(t));return k(e,R)?G.fromCIMMarker(t,e,this._tileInfo):this._markerError}async _createCIM(t){const e=t.templateHash;if(this._cimTemplateCache.has(e))return this._cimTemplateCache.get(e);let i;switch(t.type){case"marker":i=await this._createCIMMarker(t);break;case"line":i=await this._createCIMLine(t);break;case"fill":i=await this._createCIMFill(t);break;case"text":i=await this._createCIMText(t)}return this._cimTemplateCache.set(e,i),i}async _createDynamicCIM(t){const e=t.templateHash;if(this._cimTemplateCache.has(e))return this._cimTemplateCache.get(e);let i;switch(t.type){case"marker":i=_e.fromCIMMarker(t,this._tileInfo);break;case"line":i=fe.fromCIMLine(t,this._tileInfo);break;case"fill":i=ue.fromCIMFill(t,this._tileInfo);break;case"text":i=de.fromCIMText(t,this._tileInfo)}return this._cimTemplateCache.set(e,i),i}_createPrimitiveMeshTemplates(t,e,i){switch(e.type){case"esriSMS":return N(t,this._createSMS(e));case"esriPMS":return N(t,this._createPMS(e));case"esriSFS":return N(t,this._createSFS(e,i));case"line-marker":return N(t,this._createLMS(e));case"esriPFS":return N(t,this._createPFS(e,i));case"esriSLS":return N(t,this._createSLS(e,!1));case"esriTS":return N(t,this._createTS(e));default:return R.error("Unable to create mesh template for unknown symbol type {: $ }{symbol.type}"),t}}_createMeshTemplates(t,e,i){if(e.type.indexOf("3d")!==-1)return R.error("3D symbols are not supported with MapView"),t;if(e.type==="expanded-cim"){for(const r of e.layers)typeof r.materialHash=="function"?N(t,this._createDynamicCIM(r)):N(t,this._createCIM(r));return t}if(e.type==="composite-symbol"){for(const r of e.layers)this._createPrimitiveMeshTemplates(t,r,i);return t}return e.type==="cim"||e.type==="label"||e.type==="web-style"?t:this._createPrimitiveMeshTemplates(t,e,i)}}const Ts=n=>{if(!n.layers)return!1;for(const t of n.layers)if(typeof t.materialHash=="function")return!0;return!1};class Hs{constructor(t,e,i){this._loadPromise=hr(),this._geometryType=t,this._idField=e,this._templateStore=i}update(t,e){F(t.mesh.labels)&&(this._labelTemplates=this._createLabelTemplates(t.mesh.labels,e)),this._schema=t}_createLabelTemplates(t,e){const i=new Map;if(t.type==="simple"){for(const r of t.classes){const s=Ft.fromLabelClass(r,e);i.set(r.index,s)}return i}for(const r in t.classes){const s=t.classes[r];for(const a of s){const o=Ft.fromLabelClass(a,e);i.set(a.index,o)}}return i}get templates(){return this._templateStore}async analyze(t,e,i,r,s,a,o){if(Le(o))return;let l;i.type==="dictionary"&&(l=await i.analyze(this._idField,t.copy(),e,s,a,o));let h=0;for(;t.next();){let u;if(u=l?l[h++]:F(r)&&rr(t.getDisplayId())&&t.readAttribute("cluster_count")!==1?r.match(this._idField,t,this._geometryType,s,a):i.match(this._idField,t,this._geometryType,s,a),t.setGroupId(u),pt(u)){const c=this._templateStore.getDynamicTemplateGroup(u);for(const _ of c)_&&_.analyze&&_.analyze(this._templateStore,t,s,a)}}return await this._loadPromise,this._templateStore.finalize(o)}async analyzeGraphics(t,e,i,r,s,a){if(Le(a))return;const o=t.getCursor();for(i&&await i.analyze(this._idField,o.copy(),e,r,s,a);o.next();){let l=o.getGroupId();if(l!=null&&l!==-1||(l=i.match(this._idField,o,o.geometryType,r,s),o.setGroupId(l)),pt(l)){const h=this._templateStore.getDynamicTemplateGroup(l);for(const u of h)u&&u.analyze&&u.analyze(this._templateStore,o,r,s)}o.setGroupId(l)}return await this._loadPromise,this._templateStore.finalize(a)}writeGraphic(t,e,i,r){const s=e.getGroupId(),a=e.getDisplayId(),o=this._templateStore.getTemplateGroup(s);if(t.featureStart(e.insertAfter,0),a!=null){if(pt(s))for(const l of o)l&&l.bindFeature(e,null,null);if(o){for(const l of o)l&&l.write(t,e,i,r);t.featureEnd()}}}writeCursor(t,e,i,r,s,a,o){const l=e.getGroupId(),h=e.getDisplayId(),u=this._templateStore.getTemplateGroup(l),c=this._schema.mesh.sortKey;let _=0;if(F(c)&&(_=c.fieldIndex!=null?e.getComputedNumericAtIndex(c.fieldIndex):c.field!=null?e.readAttribute(c.field):e.readAttribute(this._idField),_*=c.order==="asc"?1:-1),t.featureStart(0,_==null||isNaN(_)?0:_),h!=null&&u){if(pt(l))for(const d of u)d.bindFeature(e,i,r);for(const d of u)d.write(t,e,s,o);if(F(a)&&t.hasRecords){const d=a&&this._findLabelRef(u);this._writeLabels(t,e,a,d,s,o)}t.featureEnd()}}_findLabelRef(t){for(const e of t)if(e instanceof G)return e;return null}_writeLabels(t,e,i,r,s,a){for(const o of i)if(F(o)&&o){const{glyphs:l,rtl:h,index:u}=o,c=this._labelTemplates.get(u);c.setZoomLevel(s),c.bindReferenceTemplate(r),c.bindTextInfo(l,h),c.write(t,e,null,a)}}}const Jt=_t.getLogger("esri/views/2d/engine/webgl/util/Matcher");async function $s(n,t,e,i){switch(n.type){case"simple":return it.fromBasicRenderer(n,t,e,i);case"map":return ye.fromUVRenderer(n,t,e,i);case"interval":return xe.fromCBRenderer(n,t,e,i);case"dictionary":return ge.fromDictionaryRenderer(n,t,e,i);case"subtype":return pe.fromSubtypes(n,t,e,i)}}class it{constructor(){this.type="feature",this._defaultResult=null}static async fromBasicRenderer(t,e,i,r){const s=new it;if(t.symbol){const a=await q(t.symbol,i,r),o=e.createTemplateGroup(a,null);s.setDefault(o)}return s}size(){return 1}getDefault(){return this._defaultResult}setDefault(t){this._defaultResult=t}match(t,e,i,r,s){return this.getDefault()}async analyze(t,e,i,r,s,a){return null}}class pe extends it{constructor(t,e){super(),this._subMatchers=t,this._subtypeField=e}static async fromSubtypes(t,e,i,r){const s=new Map,a=[];for(const o in t.renderers){const l=parseInt(o,10),h=$s(t.renderers[o],e,i,r).then(u=>s.set(l,u));a.push(h)}return await Promise.all(a),new pe(s,t.subtypeField)}match(t,e,i,r,s){const a=e.readAttribute(this._subtypeField),o=this._subMatchers.get(a);return o?o.match(t,e,i,r,s):null}}class xe extends it{constructor(t,e,i,r){super(),this.type="interval",this._intervals=[],this._isMaxInclusive=e,this._fieldIndex=r,this._field=t,this._normalizationInfo=i}static async fromCBRenderer(t,e,i,r){const{isMaxInclusive:s,normalizationField:a,normalizationTotal:o,normalizationType:l}=t,h=t.field,u=new xe(h,s,{normalizationField:a,normalizationTotal:o,normalizationType:l},t.fieldIndex),c=await q(t.backgroundFillSymbol,i,r);await Promise.all(t.intervals.map(async d=>{const m=await q(d.symbol,i,r),f=await e.createTemplateGroup(m,c),p={min:d.min,max:d.max};u.add(p,f)}));const _=await q(t.defaultSymbol,i,r);if(_){const d=await e.createTemplateGroup(_,c);u.setDefault(d)}return u}add(t,e){this._intervals.push({interval:t,result:e}),this._intervals.sort((i,r)=>i.interval.min-r.interval.min)}size(){return super.size()+this._intervals.length}match(t,e,i,r,s){if(this._fieldIndex==null&&!this._field)return this.getDefault();const a=this._fieldIndex!=null?e.getComputedNumericAtIndex(this._fieldIndex):this._getValueFromField(e);if(!a&&(a==null||isNaN(a)))return this.getDefault();for(let o=0;o<this._intervals.length;o++){const{interval:l,result:h}=this._intervals[o],u=a>=l.min,c=this._isMaxInclusive?a<=l.max:a<l.max;if(u&&c)return h}return this.getDefault()}_needsNormalization(){const t=this._normalizationInfo;return t&&(t.normalizationField||t.normalizationTotal||t.normalizationType)}_getValueFromField(t){const e=t.readAttribute(this._field);if(!this._needsNormalization()||e==null)return e;const{normalizationField:i,normalizationTotal:r,normalizationType:s}=this._normalizationInfo,a=!!i&&t.readAttribute(i);if(s)switch(s){case"esriNormalizeByField":return a?e/a:void 0;case"esriNormalizeByLog":return Math.log(e)*Math.LOG10E;case"esriNormalizeByPercentOfTotal":return e/r*100;default:return void Jt.error(`Found unknown normalization type: ${s}`)}else Jt.error("Normalization is required, but no type was set!")}}class ye extends it{constructor(t,e,i){super(),this.type="map",this._nullResult=null,this._resultsMap=new Map,this._fieldsIndex=i,this._fields=t,this._seperator=e||""}static async fromUVRenderer(t,e,i,r){const s=t.fieldDelimiter,a=[t.field];t.field2&&a.push(t.field2),t.field3&&a.push(t.field3);const o=await q(t.backgroundFillSymbol,i,r),l=new ye(a,s,t.fieldIndex);await Promise.all(t.map.map(async u=>{const c=await q(u.symbol,i,r),_=await e.createTemplateGroup(c,o);u.value==="<Null>"?l.setNullResult(_):l.add(u.value,_)}));const h=await q(t.defaultSymbol,i,r);if(h){const u=await e.createTemplateGroup(h,o);l.setDefault(u)}return l}setNullResult(t){this._nullResult=t}add(t,e){this._resultsMap.set(t.toString(),e)}size(){return super.size()+this._resultsMap.size}match(t,e,i,r,s){if(this._fieldsIndex==null&&!this._fields)return this.getDefault();const a=this._fieldsIndex!=null?e.getComputedStringAtIndex(this._fieldsIndex):this._getValueFromFields(e);if(this._nullResult!==null&&(a==null||a===""||a==="<Null>"))return this._nullResult;if(!a&&a==null)return this.getDefault();const o=a.toString();return this._resultsMap.has(o)?this._resultsMap.get(o):this.getDefault()}_getValueFromFields(t){const e=[];for(const i of this._fields){const r=t.readAttribute(i);r==null||r===""?e.push("<Null>"):e.push(r)}return e.join(this._seperator)}}async function Is(n,t){const e=n||1;if(typeof e=="number")return(r,s,a)=>e;const i=await Zi(e,t.spatialReference,t.fields);return(r,s,a)=>Ni(i,r,{$view:a},t.geometryType,s)||1}let Nt;async function Ws(){return Nt||(Nt=import("./createSymbolSchema.d85b2a0c.js")),Nt}class ge extends it{constructor(t,e,i,r,s,a){super(),this.type="dictionary",this._groupIdCache=new Ki(100),this._loader=t,this._fieldMap=t.fieldMap,this._symbolFields=t.getSymbolFields(),this._templates=e,this._info=i,this._scaleFn=r,this._schemaUtilsModule=s,this._symbolOptions=a}static async fromDictionaryRenderer(t,e,i,r){const[{DictionaryLoader:s},a]=await Promise.all([import("./vendor.1dc52be5.js").then(function(h){return h.xp}),Ws()]),o=new s(t.url,t.config,t.fieldMap);await o.fetchResources({spatialReference:i.spatialReference,fields:i.fields});const l=await Is(t.scaleExpression,i);return new ge(o,e,i,l,a,t.symbolOptions)}async _analyzeFeature(t,e,i,r,s){const a=t.readLegacyFeature(),o=this._scaleFn(a,i,r),l=this._attributeHash(a)+"-"+o,h=this._groupIdCache.get(l);if(h)return h;const u=dt(nt({},r),{spatialReference:this._info.spatialReference,abortOptions:s,fields:this._info.fields}),c=await this._loader.getSymbolAsync(a,u),_=this._schemaUtilsModule.createSymbolSchema(c,this._symbolOptions),d=q(_,this._info,e,s).then(m=>{if(m.type!=="expanded-cim")return Jt.error(new et("mapview-bad-type",`Found unexpected type ${m.type} in dictionary response`)),null;m.hash+="-"+o;for(const f of m.layers)f.scaleFactor=o,f.templateHash+="-"+o;return this._templates.createTemplateGroup(m,null)});return this._groupIdCache.put(l,d,1),d}async analyze(t,e,i,r,s,a){const o=e.getCursor(),l=[];for(;o.next();)l.push(this._analyzeFeature(o,i,r,s,a));return Promise.all(l)}match(t,e,i,r,s){return null}_attributeHash(t){let e="";for(const i of this._symbolFields){const r=this._fieldMap[i];r&&(e+=t.attributes[r]+"-")}return e}}export{Ys as E,zt as a,Hs as b,q as c,k as e,qs as j,$s as l,xi as t};
