var se=Object.defineProperty,ie=Object.defineProperties;var re=Object.getOwnPropertyDescriptors;var j=Object.getOwnPropertySymbols;var ae=Object.prototype.hasOwnProperty,ne=Object.prototype.propertyIsEnumerable;var q=(d,e,t)=>e in d?se(d,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):d[e]=t,N=(d,e)=>{for(var t in e||(e={}))ae.call(e,t)&&q(d,t,e[t]);if(j)for(var t of j(e))ne.call(e,t)&&q(d,t,e[t]);return d},M=(d,e)=>ie(d,re(e));import{iE as ue,d9 as ee,iF as ce,iG as he,b2 as H,aa as J,iH as C,iI as oe,aF as Q,iJ as R,iK as F,iL as m,iM as le,iN as de,iO as ye,iP as b,aJ as B,iQ as fe,iR as U,iS as O,hj as V,hJ as Z,aH as G,V as _,a8 as D,gq as L,aD as pe,iT as me,iv as xe,ie as W,iw as _e,iy as ge,bQ as we,gI as Se,iU as E,iV as Qe,iW as Re,iX as Fe}from"./vendor.1dc52be5.js";import{t as Ie}from"./QueryEngineCapabilities.650d7541.js";import{v as K,I as X,P as Y}from"./spatialQuerySupport.315abf1d.js";function Ee(d){return d.every(e=>e.statisticType!=="exceedslimit")}const g="feature-store:unsupported-query",A=new Set,be=new ue(2e6);let Ae=0;class Be{constructor(e){this.capabilities={query:Ie},this.geometryType=e.geometryType,this.hasM=e.hasM,this.hasZ=e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",()=>this.clearCache()),this.timeInfo=e.timeInfo,e.cacheSpatialQueries&&(this._geometryQueryCache=new ce(Ae+++"$$",be)),this.fieldsIndex=new he(e.fields),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority))}destroy(){this._frameTask=H(this._frameTask),this.clearCache(),J(this._geometryQueryCache),this._changeHandle=H(this._changeHandle),J(this.fieldsIndex)}get featureAdapter(){return this.featureStore.featureAdapter}get fullExtent(){const e=this.featureStore.fullBounds;return e?{xmin:e[0],ymin:e[1],xmax:e[2],ymax:e[3],spatialReference:C(this.spatialReference)}:null}get timeExtent(){return this.timeInfo?(this._timeExtent||(this._timeExtent=oe(this.timeInfo,this.featureStore)),this._timeExtent):null}clearCache(){this._geometryQueryCache&&this._geometryQueryCache.clear(),this._allItems=null,this._timeExtent=null}async executeQuery(e={},t){let s,i=Q(e);try{i=await this._schedule(()=>R(i,this.definitionExpression,this.spatialReference),t),i=await this._reschedule(()=>this._checkQuerySupport(i),t),s=await this._reschedule(()=>this._executeGeometryQuery(i,t),t),s=await this._reschedule(()=>s.executeAggregateIdsQuery(i),t),s=await this._reschedule(()=>s.executeObjectIdsQuery(i),t),s=await this._reschedule(()=>s.executeTimeQuery(i),t),s=await this._reschedule(()=>s.executeAttributesQuery(i),t)}catch(r){if(r!==F)throw r;s=new m([],null,this)}return s.createQueryResponse(i)}async executeQueryForCount(e={},t){let s=Q(e);s.returnGeometry=!1,s.returnCentroid=!1,s.outSR=null;try{s=await this._schedule(()=>R(s,this.definitionExpression,this.spatialReference),t),s=await this._reschedule(()=>this._checkQuerySupport(s),t);let i=await this._reschedule(()=>this._executeGeometryQuery(s,t),t);return i=await this._reschedule(()=>i.executeAggregateIdsQuery(s),t),i=await this._reschedule(()=>i.executeObjectIdsQuery(s),t),i=await this._reschedule(()=>i.executeTimeQuery(s),t),i=await this._reschedule(()=>i.executeAttributesQuery(s),t),i.createQueryResponseForCount(s)}catch(i){if(i!==F)throw i;return 0}}async executeQueryForExtent(e={},t){let s,i=Q(e);const r=i.outSR;try{i=await this._schedule(()=>R(i,this.definitionExpression,this.spatialReference),t),i=await this._reschedule(()=>this._checkQuerySupport(i),t),i.returnGeometry=!0,i.returnCentroid=!1,i.outSR=null,s=await this._reschedule(()=>this._executeGeometryQuery(i,t),t),s=await this._reschedule(()=>s.executeAggregateIdsQuery(i),t),s=await this._reschedule(()=>s.executeObjectIdsQuery(i),t),s=await this._reschedule(()=>s.executeTimeQuery(i),t),s=await this._reschedule(()=>s.executeAttributesQuery(i),t);const n=s.size;if(!n)return{count:n,extent:null};le(p,de),this.featureStore.forEachBounds(s.items,c=>ye(p,c),ke);const u={xmin:p[0],ymin:p[1],xmax:p[3],ymax:p[4],spatialReference:C(this.spatialReference)};this.hasZ&&isFinite(p[2])&&isFinite(p[5])&&(u.zmin=p[2],u.zmax=p[5]);const a=b(u,s.spatialReference,r);if(a.spatialReference=C(r||this.spatialReference),a.xmax-a.xmin==0){const c=B(a.spatialReference);a.xmin-=c,a.xmax+=c}if(a.ymax-a.ymin==0){const c=B(a.spatialReference);a.ymin-=c,a.ymax+=c}if(this.hasZ&&a.zmin!=null&&a.zmax!=null&&a.zmax-a.zmin==0){const c=B(a.spatialReference);a.zmin-=c,a.zmax+=c}return{count:n,extent:a}}catch(n){if(n===F)return{count:0,extent:null};throw n}}async executeQueryForIds(e={},t){return this.executeQueryForIdSet(e,t).then(s=>Array.from(s))}async executeQueryForIdSet(e={},t){let s,i=Q(e);i.returnGeometry=!1,i.returnCentroid=!1,i.outSR=null;try{i=await this._schedule(()=>R(i,this.definitionExpression,this.spatialReference),t),i=await this._reschedule(()=>this._checkQuerySupport(i),t),s=await this._reschedule(()=>this._executeGeometryQuery(i,t),t),s=await this._reschedule(()=>s.executeAggregateIdsQuery(i),t),s=await this._reschedule(()=>s.executeObjectIdsQuery(i),t),s=await this._reschedule(()=>s.executeTimeQuery(i),t),s=await this._reschedule(()=>s.executeAttributesQuery(i),t);const r=s.items,n=new Set;return await this._reschedule(()=>{for(const u of r)n.add(s.featureAdapter.getObjectId(u))},t),n}catch(r){if(r===F)return new Set;throw r}}async executeQueryForSnapping(e,t){const{point:s,distance:i,types:r}=e;if(r===fe.NONE)return{candidates:[]};const n=await this._reschedule(()=>this._checkQuerySupport(e.query),t),u=!U(s.spatialReference,this.spatialReference);u&&await O(s.spatialReference,this.spatialReference);const a=typeof i=="number"?i:i.x,c=typeof i=="number"?i:i.y,l={xmin:s.x-a,xmax:s.x+a,ymin:s.y-c,ymax:s.y+c,spatialReference:s.spatialReference},h=u?b(l,this.spatialReference):l;if(!h)return{candidates:[]};const f=(await V(Z(s),null,{signal:t}))[0],x=(await V(Z(h),null,{signal:t}))[0];if(G(f)||G(x))return{candidates:[]};let y=new m(this._searchFeatures(this._getQueryBBoxes(x.toJSON())),null,this);y=await this._reschedule(()=>y.executeObjectIdsQuery(n),t),y=await this._reschedule(()=>y.executeTimeQuery(n),t),y=await this._reschedule(()=>y.executeAttributesQuery(n),t);const S=f.toJSON(),k=u?b(S,this.spatialReference):S,T=u?Math.max(h.xmax-h.xmin,h.ymax-h.ymin)/2:i;return y.createSnappingResponse(M(N({},e),{point:k,distance:T}),s.spatialReference)}async executeQueryForLatestObservations(e={},t){if(!this.timeInfo||!this.timeInfo.trackIdField)throw new _(g,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});let s,i=Q(e);try{i=await this._schedule(()=>R(i,this.definitionExpression,this.spatialReference),t),i=await this._reschedule(()=>this._checkQuerySupport(i),t),s=await this._reschedule(()=>this._executeGeometryQuery(i,t),t),s=await this._reschedule(()=>s.executeAggregateIdsQuery(i),t),s=await this._reschedule(()=>s.executeObjectIdsQuery(i),t),s=await this._reschedule(()=>s.executeTimeQuery(i),t),s=await this._reschedule(()=>s.executeAttributesQuery(i),t),s=await this._reschedule(()=>s.filterLatest(),t)}catch(r){if(r!==F)throw r;s=new m([],null,this)}return s.createQueryResponse(i)}async executeQueryForSummaryStatistics(e={},t,s){const{field:i,normalizationField:r,valueExpression:n}=t;return(await this._getQueryEngineResultForStats(e,{field:i,normalizationField:r,valueExpression:n},s)).createSummaryStatisticsResponse(e,t)}async executeQueryForUniqueValues(e={},t,s){const{field:i,valueExpression:r}=t;return(await this._getQueryEngineResultForStats(e,{field:i,valueExpression:r},s)).createUniqueValuesResponse(e,t)}async executeQueryForClassBreaks(e={},t,s){const{field:i,normalizationField:r,valueExpression:n}=t;return(await this._getQueryEngineResultForStats(e,{field:i,normalizationField:r,valueExpression:n},s)).createClassBreaksResponse(e,t)}async executeQueryForHistogram(e={},t,s){const{field:i,normalizationField:r,valueExpression:n}=t;return(await this._getQueryEngineResultForStats(e,{field:i,normalizationField:r,valueExpression:n},s)).createHistogramResponse(e,t)}async _schedule(e,t){return D(this._frameTask)?this._frameTask.schedule(e,t):e(L)}async _reschedule(e,t){return D(this._frameTask)?this._frameTask.reschedule(e,t):e(L)}_getAll(){if(!this._allItems){const e=[];this.featureStore.forEach(t=>e.push(t)),this._allItems=new m(e,null,this)}return this._allItems}async _executeGeometryQuery(e,t){const{geometry:s,outSR:i,spatialRel:r,returnGeometry:n,returnCentroid:u}=e,a=this.featureStore.featureSpatialReference,c=s&&a&&a!==s.spatialReference?b(s,a):s,l=n||u,h=pe(i)&&!U(this.spatialReference,i),f=this._geometryQueryCache?h&&l?JSON.stringify({originalFilterGeometry:s,spatialRelationship:r,outSpatialReference:i}):JSON.stringify({originalFilterGeometry:s,spatialRelationship:r}):null;if(f){const o=this._geometryQueryCache.get(f);if(!me(o))return o}const x=async o=>{if(h&&l){const w=await o.project(i);return f&&this._geometryQueryCache.put(f,w,w.size||1),w}return f&&this._geometryQueryCache.put(f,o,o.size||1),o};if(!c)return x(this._getAll());const y=this.featureAdapter;if(r==="esriSpatialRelDisjoint"){const o=this._searchFeatures(this._getQueryBBoxes(s));if(!o.length)return x(this._getAll());let w,P;const z=new Set;for(const I of o)z.add(y.getObjectId(I));await this._reschedule(()=>{let I=0;w=new Array(z.size),this.featureStore.forEach(v=>w[I++]=v),P=z},t);const te=await this._reschedule(async()=>{const I=await K(r,c,this.geometryType,this.hasZ,this.hasM),v=$=>!P.has(y.getObjectId($))||I(y.getGeometry($));return new m(await this._runSpatialFilter(w,v,t),s,this)},t);return x(te)}const S=this._searchFeatures(this._getQueryBBoxes(s));if(!S.length){const o=new m([],s,this);return f&&this._geometryQueryCache.put(f,o,o.size||1),o}if(this._canExecuteSoloPass(c,e))return x(new m(S,s,this));const k=await K(r,c,this.geometryType,this.hasZ,this.hasM),T=await this._runSpatialFilter(S,o=>k(y.getGeometry(o)),t);return x(new m(T,s,this))}async _runSpatialFilter(e,t,s){if(!t)return e;if(G(this._frameTask))return e.filter(u=>t(u));let i=0;const r=new Array,n=async u=>{for(;i<e.length;){const a=e[i++];t(a)&&(r.push(a),u.madeProgress()),u.done&&await this._reschedule(c=>n(c),s)}};return this._reschedule(u=>n(u),s).then(()=>r)}_canExecuteSoloPass(e,t){const{geometryType:s}=this,{spatialRel:i}=t;return X(e)&&(i==="esriSpatialRelEnvelopeIntersects"||s==="esriGeometryPoint"&&(i==="esriSpatialRelIntersects"||i==="esriSpatialRelContains"||i==="esriSpatialRelWithin"))}_getQueryBBoxes(e){if(X(e)){if(xe(e))return[W(e.xmin,e.ymin,e.xmax,e.ymax)];if(_e(e))return e.rings.map(t=>W(Math.min(t[0][0],t[2][0]),Math.min(t[0][1],t[2][1]),Math.max(t[0][0],t[2][0]),Math.max(t[0][1],t[2][1])))}return[ge(we(),e)]}_searchFeatures(e){for(const i of e)this.featureStore.forEachInBounds(i,r=>{A.add(r)});const t=new Array(A.size);let s=0;return A.forEach(i=>t[s++]=i),A.clear(),t}async _checkStatisticsSupport(e,t){if(e.distance<0||e.geometryPrecision!=null||e.multipatchOption||e.pixelSize||e.relationParam||e.text||e.outStatistics||e.groupByFieldsForStatistics||e.having||e.orderByFields)throw new _(g,"Unsupported query options",{query:e});return Promise.all([this._checkAttributesQuerySupport(e),this._checkStatisticsParamsSupport(t),Y(e,this.geometryType,this.spatialReference),O(this.spatialReference,e.outSR)]).then(()=>e)}async _checkStatisticsParamsSupport(e){let t=[];if(e.valueExpression){const{arcadeUtils:s}=await Se();t=s.extractFieldNames(e.valueExpression)}if(e.field&&t.push(e.field),e.normalizationField&&t.push(e.normalizationField),!t.length)throw new _(g,"params should have at least a field or valueExpression",{params:e});E(this.fieldsIndex,t,"params contains missing fields")}async _checkQuerySupport(e){if(e.distance<0||e.geometryPrecision!=null||e.multipatchOption||e.pixelSize||e.relationParam||e.text)throw new _(g,"Unsupported query options",{query:e});return Promise.all([this._checkAttributesQuerySupport(e),this._checkStatisticsQuerySupport(e),Y(e,this.geometryType,this.spatialReference),O(this.spatialReference,e.outSR)]).then(()=>e)}_checkAttributesQuerySupport(e){const{outFields:t,orderByFields:s,returnDistinctValues:i,outStatistics:r}=e,n=r?r.map(u=>u.outStatisticFieldName&&u.outStatisticFieldName.toLowerCase()).filter(Boolean):[];if(s&&s.length>0){const u=" asc",a=" desc",c=s.map(l=>{const h=l.toLowerCase();return h.indexOf(u)>-1?h.split(u)[0]:h.indexOf(a)>-1?h.split(a)[0]:l}).filter(l=>n.indexOf(l)===-1);E(this.fieldsIndex,c,"orderByFields contains missing fields")}if(t&&t.length>0)E(this.fieldsIndex,t,"outFields contains missing fields");else if(i)throw new _(g,"outFields should be specified for returnDistinctValues",{query:e});Qe(this.fieldsIndex,e.where)}async _checkStatisticsQuerySupport(e){const{outStatistics:t,groupByFieldsForStatistics:s,having:i}=e,r=s&&s.length,n=t&&t.length;if(i){if(!r||!n)throw new _(g,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:e});Re(this.fieldsIndex,i,t)}if(n){if(!Ee(t))return;const u=t.map(a=>a.onStatisticField).filter(Boolean);E(this.fieldsIndex,u,"onStatisticFields contains missing fields"),r&&E(this.fieldsIndex,s,"groupByFieldsForStatistics contains missing fields");for(const a of t){const{onStatisticField:c,statisticType:l}=a;if((l==="percentile_disc"||l==="percentile_cont")&&"statisticParameters"in a){const{statisticParameters:h}=a;if(!h)throw new _(g,"statisticParamters should be set for percentile type",{definition:a,query:e})}else if(l!=="count"&&c&&Fe(c,this.fieldsIndex))throw new _(g,"outStatistics contains non-numeric fields",{definition:a,query:e})}}}async _getQueryEngineResultForStats(e={},t,s){let i;e=Q(e);try{e=await this._schedule(()=>R(e,this.definitionExpression,this.spatialReference),s),e=await this._reschedule(()=>this._checkStatisticsSupport(e,t),s),i=await this._reschedule(()=>this._executeGeometryQuery(e,s),s),i=await this._reschedule(()=>i.executeAggregateIdsQuery(e),s),i=await this._reschedule(()=>i.executeObjectIdsQuery(e),s),i=await this._reschedule(()=>i.executeTimeQuery(e),s),i=await this._reschedule(()=>i.executeAttributesQuery(e),s)}catch(r){if(r!==F)throw r;i=new m([],null,this)}return i}}const ke=ee(),p=ee();export{Be as V};
