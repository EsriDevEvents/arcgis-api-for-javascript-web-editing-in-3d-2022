var de=Object.defineProperty,fe=Object.defineProperties;var ce=Object.getOwnPropertyDescriptors;var G=Object.getOwnPropertySymbols;var pe=Object.prototype.hasOwnProperty,me=Object.prototype.propertyIsEnumerable;var j=(e,i,t)=>i in e?de(e,i,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[i]=t,v=(e,i)=>{for(var t in i||(i={}))pe.call(i,t)&&j(e,t,i[t]);if(G)for(var t of G(i))me.call(i,t)&&j(e,t,i[t]);return e},h=(e,i)=>fe(e,ce(i));import{aM as q,qy as K,ac as k,ad as ye,qU as ge,ae as be,I as ie,k4 as H,aF as se,dP as U,aH as J,tr as T,V as g,a8 as D,a7 as _,ft as W,a6 as ve}from"./vendor.1dc52be5.js";import{A as R,W as xe}from"./Utils.25ecb0e0.js";import{o as he}from"./visualVariablesUtils.2f752113.js";import{createSymbolSchema as S}from"./createSymbolSchema.d85b2a0c.js";import{t as we}from"./CIMSymbolHelper.e5777d0e.js";import{k as ze}from"./definitions.52b5fae8.js";import"./alignmentUtils.03ee467b.js";import"./number.dc47462b.js";import"./cimAnalyzer.13178822.js";import"./ExpandedCIM.b5e8a891.js";import{x as A}from"./MD5.67d7a872.js";import{e as Se}from"./util.2009583e.js";function Ee(e){if(!e)return R.NONE;let i=0;for(const t of e)if(t.type==="size"){const s=he(t);i|=s,t.target==="outline"&&(i|=s<<4)}else t.type==="color"?i|=R.COLOR:t.type==="opacity"?i|=R.OPACITY:t.type==="rotation"&&(i|=R.ROTATION);return i}function Fe(e){if(!("visualVariables"in e)||!e.hasVisualVariables("size"))return 0;const i=e.getVisualVariablesForType("size");if(!i[0])return 0;const t=i[0];if(t.target==="outline")return 0;if(t.transformationType==="stops")return t.stops.map(s=>s.size).reduce(L,0);if(t.transformationType==="clamped-linear"){let s=-1/0,n=-1/0;return s=typeof t.maxSize=="number"?t.maxSize:t.maxSize.stops.map(l=>l.size).reduce(L,0),n=typeof t.minSize=="number"?t.minSize:t.minSize.stops.map(l=>l.size).reduce(L,0),Math.max(s,n)}return t.transformationType==="real-world-size"?30:void 0}ze.metrics,new we(0,0,24,24);function L(e,i){return Math.max(e,i)}const C=8,ne=C-2,Ve=q.getLogger("esri.renderers.visualVariables.support.utils"),ct=e=>{if(!("visualVariables"in e)||!e.visualVariables||!e.visualVariables.length)return e;const i=e.clone(),t=i.visualVariables.map(s=>le(s)?re(s):s);return i.visualVariables=t,i};function $e(e){return e.map(i=>le(i)?re(i.clone()):i)}function le(e){return(e.type==="size"||e.type==="color"||e.type==="opacity")&&e.stops!=null}function re(e){return e.stops=Oe(e.type,e.stops),e}function F(e,i,t){return(1-t)*e+t*i}function Ie(e,i){const[t,...s]=i,n=s.pop(),l=s[0].value,a=s[s.length-1].value,r=(a-l)/ne,o=[];for(let u=l;u<a;u+=r){let d=0;for(;u>=s[d].value;)d++;const y=s[d],f=i[d-1],p=u-f.value,x=y.value===f.value?1:p/(y.value-f.value);if(e==="color"){const b=s[d],m=i[d-1],c=b.color.clone();c.r=F(m.color.r,c.r,x),c.g=F(m.color.g,c.g,x),c.b=F(m.color.b,c.b,x),c.a=F(m.color.a,c.a,x),o.push({value:u,color:c,label:b.label})}else if(e==="size"){const b=s[d],m=i[d-1],c=K(b.size),M=F(K(m.size),c,x);o.push({value:u,size:M,label:b.label})}else{const b=s[d],m=F(i[d-1].opacity,b.opacity,x);o.push({value:u,opacity:m,label:b.label})}}return[t,...o,n]}function Te(e){const[i,...t]=e,s=t.pop();for(;t.length>ne;){let n=0,l=0;for(let a=1;a<t.length;a++){const r=t[a-1],o=t[a],u=Math.abs(o.value-r.value);u>l&&(l=u,n=a)}t.splice(n,1)}return[i,...t,s]}function Oe(e,i){return i.length<=C?i:(Ve.warn(`Found ${i.length} Visual Variable stops, but MapView only supports ${C}. Displayed stops will be simplified.`),i.length>2*C?Ie(e,i):Te(i))}var P;let O=P=class extends ie{writeLevels(e,i,t){for(const s in e){const n=this.levels[s];return void(i.stops=n)}}clone(){return new P({axis:this.axis,field:this.field,valueExpression:this.valueExpression,valueExpressionTitle:this.valueExpressionTitle,maxDataValue:this.maxDataValue,maxSize:H(this.maxSize)?this.maxSize.clone():this.maxSize,minDataValue:this.minDataValue,minSize:H(this.minSize)?this.minSize.clone():this.minSize,normalizationField:this.normalizationField,stops:this.stops&&this.stops.map(e=>e.clone()),target:this.target,useSymbolValue:this.useSymbolValue,valueRepresentation:this.valueRepresentation,valueUnit:this.valueUnit,legendOptions:this.legendOptions&&this.legendOptions.clone(),levels:se(this.levels)})}};k([ye()],O.prototype,"levels",void 0),k([ge("levels")],O.prototype,"writeLevels",null),O=P=k([be("esri.views.2d.engine.LevelDependentSizeVariable")],O);const ae=q.getLogger("esri.views.2d.layers.support.clusterUtils");U.add("esri-cluster-arcade-enabled",!0);const Me=U("esri-cluster-arcade-enabled"),Re=(e,i,t,s)=>{const n=i.clone();if(!_e(n))return n;if(t.fields)for(const l of t.fields)Be(e,l);if("visualVariables"in n){const l=(n.visualVariables||[]).filter(r=>r.valueExpression!=="$view.scale"),a=Ne(l);l.forEach(r=>{r.type==="rotation"?r.field?r.field=V(e,r.field,"avg_angle"):r.valueExpression&&(r.field=N(e,r.valueExpression,"avg_angle"),r.valueExpression=null):r.normalizationField?(r.field=V(e,r.field,"norm",r.normalizationField),r.normalizationField=null):r.field?r.field=V(e,r.field,"avg"):(r.field=N(e,r.valueExpression,"avg"),r.valueExpression=null)}),J(a)&&!Ce(l)&&(l.push(ke(t,s)),n.dynamicClusterSize=!0),n.visualVariables=l}switch(n.type){case"simple":break;case"unique-value":n.field?n.field=V(e,n.field,"mode"):n.valueExpression&&(n.field=N(e,n.valueExpression,"mode"),n.valueExpression=null);break;case"class-breaks":n.normalizationField?(n.field=V(e,n.field,"norm",n.normalizationField),n.normalizationField=null):n.field?n.field=V(e,n.field,"avg"):(n.field=N(e,n.valueExpression,"avg"),n.valueExpression=null)}return n},Ne=e=>{for(const i of e)if(i.type==="size")return i;return null},Ce=e=>{for(const i of e)if(i.field==="cluster_count")return!0;return!1},ke=(e,i)=>{const t=[new T({value:0,size:0}),new T({value:1})];if(J(i))return new ie({field:"cluster_count",stops:[...t,new T({value:2,size:0})]});const s=Object.keys(i).reduce((n,l)=>h(v({},n),{[l]:[...t,new T({value:Math.max(2,i[l].minValue),size:e.clusterMinSize}),new T({value:Math.max(3,i[l].maxValue),size:e.clusterMaxSize})]}),{});return new O({field:"cluster_count",levels:s})},_e=e=>{const i=t=>ae.error(new g("Unsupported-renderer",t,{renderer:e}));if(e.type==="unique-value"){if(e.field2||e.field3)return i("FeatureReductionCluster does not support multi-field UniqueValueRenderers"),!1}else if(e.type==="class-breaks"){if(e.normalizationField){const t=e.normalizationType;if(t!=="field")return i(`FeatureReductionCluster does not support a normalizationType of ${t}`),!1}}else if(e.type!=="simple")return i(`FeatureReductionCluster does not support renderers of type ${e.type}`),!1;if(!Me){if("valueExpression"in e&&e.valueExpression)return i("FeatureReductionCluster does not currently support renderer.valueExpression. Support will be added in a future release"),!1;if(("visualVariables"in e&&e.visualVariables||[]).some(t=>!(!("valueExpression"in t)||!t.valueExpression)))return i("FeatureReductionCluster does not currently support visualVariables with a valueExpression. Support will be added in a future release"),!1}return!0};function Le(e,i,t){switch(e){case"avg":case"avg_angle":return`cluster_avg_${i}`;case"mode":return`cluster_type_${i}`;case"norm":{const s=t,n="field",l=i.toLowerCase()+",norm:"+n+","+s.toLowerCase();return"cluster_avg_"+A(l)}}}function Be(e,i){const{name:t,outStatistic:s}=i,{onStatisticField:n,onStatisticValueExpression:l,statisticType:a}=s;if(l){const r=A(l.toLowerCase());e.push({name:t,outStatistic:{onStatisticField:r,onStatisticValueExpression:l,statisticType:a}})}else n?e.push({name:t,outStatistic:{onStatisticField:n,statisticType:a}}):ae.error(new g("mapview-unsupported-field","Unable to handle field",{field:i}))}function N(e,i,t){const s=A(i),n=t==="mode"?`cluster_type_${s}`:`cluster_avg_${s}`;return e.some(l=>l.name===n)||e.push({name:n,outStatistic:{onStatisticField:s,onStatisticValueExpression:i,statisticType:t}}),n}function V(e,i,t,s){if(i==="cluster_count"||e.some(l=>l.name===i))return i;const n=Le(t,i,s);return e.some(l=>l.name===n)||(t==="norm"?e.push({name:n,outStatistic:{onStatisticField:i,onStatisticNormalizationField:s,statisticType:t}}):e.push({name:n,outStatistic:{onStatisticField:i,statisticType:t}})),n}const $=q.getLogger("esri.views.2d.layers.features.schemaUtils"),w="ValidationError",De={esriGeometryPoint:["above-right","above-center","above-left","center-center","center-left","center-right","below-center","below-left","below-right"],esriGeometryPolygon:["always-horizontal"],esriGeometryPolyline:["center-along"],esriGeometryMultipoint:null};function I(e){let i=0,t=0,s=!1,n=!0,l=!0;if(D(e)){if(t=Fe(e),"visualVariables"in e&&(i=Ee(e.visualVariables||[]),s=e.type==="dot-density"),e.type==="dictionary")return{maxVVSize:t,supportsOutlineFills:!1,vvFlags:i,stride:{fill:"default"}};if(!s){const a=e.getSymbols();"backgroundFillSymbol"in e&&e.backgroundFillSymbol&&a.push(e.backgroundFillSymbol);for(const r of a)if(r.type==="cim"&&(n=!1),r.type==="simple-fill"||r.type==="picture-fill"){const o=r.outline;o&&o.style!=="none"&&o.style!=="solid"&&(l=!1);const u=o&&o.style!=="none"&&o.style!=="solid",d=r.type==="simple-fill"&&r.style!=="none"&&r.style!=="solid";(r.type==="picture-fill"||d||u)&&(n=!1)}}}return s&&(l=!1),{vvFlags:i,maxVVSize:t,supportsOutlineFills:l,stride:{fill:s?"dot-density":n?"simple":"default"}}}function Pe(e,i){const t=e.labelPlacement,s=De[i];if(!e.symbol)return $.warn("No ILabelClass symbol specified."),!0;if(!s)return $.error(new g("mapview-labeling:unsupported-geometry-type",`Unable to create labels for Feature Layer, ${i} is not supported`)),!0;if(!s.some(n=>n===t)){const n=s[0];t&&$.warn(`Found invalid label placement type ${t} for ${i}. Defaulting to ${n}`),e.labelPlacement=n}return!1}function Y(e,i){const t=se(e);return t.some(s=>Pe(s,i))?[]:t}function pt(e){return U("esri-2d-update-debug")&&console.debug("Created new schema",Q(e,!0)),Q(e)}function Q(e,i=!1){try{var t,s;const n=Je(e,i),l={};return n.map(a=>qe(l,e,a)),{source:{definitionExpression:e.definitionExpression,fields:e.fields.map(a=>a.toJSON()),gdbVersion:e.gdbVersion,historicMoment:(t=e.historicMoment)==null?void 0:t.getTime(),outFields:e.availableFields,pixelBuffer:e.pixelBuffer,spatialReference:e.spatialReference.toJSON(),timeExtent:(s=e.timeExtent)==null?void 0:s.toJSON(),customParameters:e.customParameters},attributes:{fields:{},indexCount:0},processors:n,targets:l}}catch(n){if(n.fieldName===w)return $.error(n),null;throw n}}function qe(e,i,t){switch(t.target){case"feature":return void Z(e,X(i),t);case"aggregate":{if(!("featureReduction"in i))return;const s=i.featureReduction;if(s.type==="selection")throw new g(w,"Mapview does not support `selection` reduction type",s);return Z(e,X(i),t),void Ue(e,s,t)}}}function oe(e,i){for(const t in i){const s=i[t];if(s.target!==e.name)continue;const n=e.attributes[t];n?(n.context.mesh=n.context.mesh||s.context.mesh,n.context.storage=n.context.storage||s.context.storage):e.attributes[t]=s}return e}function X(e){var i,t,s,n,l;return[(i=(t=_(e.filter))==null?void 0:t.toJSON())!=null?i:null,(s=(n=_((l=_(e.featureEffect))==null?void 0:l.filter))==null?void 0:n.toJSON())!=null?s:null]}function Z(e,i,t){return e.feature||(e.feature={name:"feature",input:"source",filters:i,attributes:{}}),oe(e.feature,t.attributes.fields),e}function Ue(e,i,t){return e.aggregate||(e.aggregate={name:"aggregate",input:"feature",filters:null,attributes:{},params:{clusterRadius:W(i.clusterRadius/2),clusterPixelBuffer:64*Math.ceil(W(i.clusterMaxSize)/64),fields:t.aggregateFields}}),oe(e.aggregate,t.attributes.fields),e}function z(e,i){return i.field?E(e,h(v({},i),{type:"field",field:i.field})):i.valueExpression?E(e,h(v({},i),{type:"expression",valueExpression:i.valueExpression})):{field:null,fieldIndex:null}}function E(e,i){switch(i.type){case"expression":{const t=i.valueExpression;if(!e.fields[t]){const s=e.indexCount++;e.fields[t]=h(v({},i),{name:t,fieldIndex:s})}return{fieldIndex:e.fields[t].fieldIndex}}case"label-expression":{const t=JSON.stringify(i.label);if(!e.fields[t]){const s=e.indexCount++;e.fields[t]=h(v({},i),{name:t,fieldIndex:s})}return{fieldIndex:e.fields[t].fieldIndex}}case"field":{const t=i.field;return i.target==="aggregate"&&e.fields[t]||(e.fields[t]=h(v({},i),{name:t})),{field:t}}case"statistic":return e.fields[i.name]=v({},i),{field:i.name}}}function Je(e,i=!1){const t=new Array;let s=0;return t.push(Ae(e,s++,i)),t}function B(e,i,t,s,n,l=!1){const a=E(i,{type:"label-expression",target:s,context:{mesh:!0},resultType:"string",label:{labelExpression:t.labelExpression,labelExpressionInfo:t.labelExpressionInfo?{expression:t.labelExpressionInfo.expression}:null,symbol:!!t.symbol,where:t.where}}),{fieldIndex:r}=a,o=I(e);return h(v({},S(t,o,l)),{fieldIndex:r,target:s,index:n})}function Ae(e,i,t=!1){const s={indexCount:0,fields:{}},n="featureReduction"in e&&e.featureReduction,l=n?"aggregate":"feature";if("sublayers"in e){const a={type:"subtype",subtypeField:e.subtypeField,renderers:{},stride:{fill:"default"}},r={type:"subtype",mapping:{},target:"feature"},o={type:"subtype",classes:{}},u={type:"symbol",target:"feature",aggregateFields:[],attributes:s,storage:r,mesh:{matcher:a,aggregateMatcher:null,labels:o,sortKey:null}},d=new Set;let y=0;for(const{renderer:f,subtypeCode:p,labelingInfo:x,labelsVisible:b}of e.sublayers){const m=te(s,l,f,t),c=ee(s,l,f),M=b&&x;if("visualVariables"in f&&f.visualVariables&&f.visualVariables.length)throw new g(w,"Visual variables are currently not supported for subtype layers");if(m.type==="dictionary")throw new g(w,"Dictionary renderer is not supported in subtype layers");if(m.type==="subtype")throw new g(w,"Nested subtype renderers is not supported");if(D(c)&&c.type==="subtype")throw new g(w,"Nested subtype storage is not supported");if(D(c)&&c.type==="dot-density")throw new g(w,"Dot density attributes are not supported in subtype layers");if(d.has(p))throw new g(w,"Subtype codes for sublayers must be unique");d.add(p),a.renderers[p]=m,r.mapping[p]=c,M&&(o.classes[p]=M.map(ue=>B(f,s,ue,"feature",y++,t)))}return u}if(e.renderer.type==="heatmap"){const{blurRadius:a,fieldOffset:r,field:o}=e.renderer;return{type:"heatmap",aggregateFields:[],attributes:s,target:l,storage:null,mesh:{blurRadius:a,fieldOffset:r,field:z(s,{target:l,field:o,resultType:"numeric"}).field}}}{const a=[],r=l==="aggregate"?Re(a,e.renderer,n,null):e.renderer;je(s,a);const o=te(s,l,r,t);let u=null;const d=ee(s,l,r),y=Se(e.geometryType);let f=e.labelsVisible&&e.labelingInfo||[],p=[];if(n){if(n.type==="selection")throw new g(w,"Mapview does not support `selection` reduction type",n);if(n.symbol){const c=I(r);u={type:"simple",symbol:S(n.symbol,c,t),stride:c.stride}}p=n&&n.labelsVisible&&n.labelingInfo||[]}f=Y(f,y),p=Y(p,y);let x=0;const b=[...f.map(c=>B(r,s,c,"feature",x++,t)),...p.map(c=>B(r,s,c,"aggregate",x++,t))],m=Ge(s,e.orderBy);return{type:"symbol",target:l,attributes:s,aggregateFields:a,storage:d,mesh:{matcher:o,labels:{type:"simple",classes:b},aggregateMatcher:u,sortKey:m}}}}function Ge(e,i){if(J(i)||!i.length)return null;i.length>1&&$.warn(`Layer rendering currently only supports ordering by 1 orderByInfo, but found ${i.length}. All but the first will be discarded`);const t=i[0],s=t.order==="ascending"?"asc":"desc";return t.field?{field:t.field,order:s}:t.valueExpression?{fieldIndex:E(e,{type:"expression",target:"feature",valueExpression:t.valueExpression,resultType:"numeric"}).fieldIndex,order:s}:($.error(new g(w,"Expected to find a field or valueExpression for OrderByInfo",t)),null)}function je(e,i){const t={mesh:!0,storage:!0};for(const s of i){const{name:n,outStatistic:l}=s,{statisticType:a,onStatisticField:r}=l;let o=null,u=null,d=null;const y="numeric",f="feature";"onStatisticValueExpression"in l?u=E(e,{type:"expression",target:f,valueExpression:l.onStatisticValueExpression,resultType:y}).fieldIndex:"onStatisticNormalizationField"in l?(o=E(e,{type:"field",target:f,field:r,resultType:y}).field,d=l.onStatisticNormalizationField):o=E(e,{type:"field",target:f,field:r,resultType:y}).field,E(e,{type:"statistic",target:"aggregate",name:n,context:t,inField:o,inNormalizationField:d,inFieldIndex:u,statisticType:a})}}function ee(e,i,t){switch(t.type){case"dot-density":return Ke(e,i,t.attributes);case"simple":case"class-breaks":case"unique-value":case"dictionary":return He(e,i,t.visualVariables);case"heatmap":return null}}function Ke(e,i,t){return!t||!t.length?{type:"dot-density",mapping:[],target:i}:{type:"dot-density",mapping:t.map((s,n)=>{const{field:l,fieldIndex:a}=z(e,{valueExpression:s.valueExpression,field:s.field,resultType:"numeric",target:i});return{binding:n,field:l,fieldIndex:a}}),target:i}}function He(e,i,t){if(!t||!t.length)return{type:"visual-variable",mapping:[],target:i};const s={storage:!0},n="numeric";return{type:"visual-variable",mapping:$e(t).map(l=>{var a;const r=xe(l.type),{field:o,fieldIndex:u}=z(e,{target:i,valueExpression:l.valueExpression,field:l.field,context:s,resultType:n});switch(l.type){case"size":return l.valueExpression==="$view.scale"?null:{type:"size",binding:r,field:o,fieldIndex:u,normalizationField:z(e,{target:i,field:l.normalizationField,context:s,resultType:n}).field,valueRepresentation:(a=l.valueRepresentation)!=null?a:null};case"color":return{type:"color",binding:r,field:o,fieldIndex:u,normalizationField:z(e,{target:i,field:l.normalizationField,context:s,resultType:n}).field};case"opacity":return{type:"opacity",binding:r,field:o,fieldIndex:u,normalizationField:z(e,{target:i,field:l.normalizationField,context:s,resultType:n}).field};case"rotation":return{type:"rotation",binding:r,field:o,fieldIndex:u}}}).filter(l=>l),target:i}}function te(e,i,t,s=!1){const n=ve(e,{indexCount:0,fields:{}});switch(t.type){case"simple":case"dot-density":return We(n,t,s);case"class-breaks":return Ye(n,i,t,s);case"unique-value":return Qe(n,i,t,s);case"dictionary":return Xe(n,t,s)}}function We(e,i,t=!1){const s=i.getSymbols(),n=s.length?s[0]:null,l=I(i);return{type:"simple",symbol:S(n,l,t),stride:l.stride}}function Ye(e,i,t,s=!1){const n={mesh:!0,use:"renderer.field"},l=t.backgroundFillSymbol,{field:a,fieldIndex:r}=z(e,{target:i,field:t.field,valueExpression:t.valueExpression,resultType:"numeric",context:n}),o=t.normalizationType,u=o==="log"?"esriNormalizeByLog":o==="percent-of-total"?"esriNormalizeByPercentOfTotal":o==="field"?"esriNormalizeByField":null,d=I(t),y=t.classBreakInfos.map(f=>({symbol:S(f.symbol,d,s),min:f.minValue,max:f.maxValue})).sort((f,p)=>f.min-p.min);return{type:"interval",attributes:e.fields,field:a,fieldIndex:r,backgroundFillSymbol:S(l,d,s),defaultSymbol:S(t.defaultSymbol,d,s),intervals:y,normalizationField:t.normalizationField,normalizationTotal:t.normalizationTotal,normalizationType:u,isMaxInclusive:t.isMaxInclusive,stride:d.stride}}function Qe(e,i,t,s=!1){const n=[],l=t.backgroundFillSymbol,a={target:i,context:{mesh:!0},resultType:"string"};if(t.field&&typeof t.field!="string")throw new g(w,"Expected renderer.field to be a string",t);const{field:r,fieldIndex:o}=z(e,h(v({},a),{field:t.field,valueExpression:t.valueExpression})),u=I(t);for(const d of t.uniqueValueInfos)n.push({value:""+d.value,symbol:S(d.symbol,u,s)});return{type:"map",attributes:e.fields,field:r,fieldIndex:o,field2:z(e,h(v({},a),{field:t.field2})).field,field3:z(e,h(v({},a),{field:t.field3})).field,fieldDelimiter:t.fieldDelimiter,backgroundFillSymbol:S(l,u),defaultSymbol:S(t.defaultSymbol,u),map:n,stride:u.stride}}function Xe(e,i,t=!1){const s=I(i);return{type:"dictionary",config:i.config,fieldMap:i.fieldMap,scaleExpression:i.scaleExpression,url:i.url,symbolOptions:s,stride:s.stride}}export{pt as I,te as L,Re as c,Ne as d,ke as f,I as h,_e as m,ct as s};
