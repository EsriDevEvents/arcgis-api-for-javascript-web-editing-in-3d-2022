import{iY as q,iZ as C,iw as h,i_ as g,g0 as v,iv as R,i$ as j,j0 as f,j1 as D,V as m,aD as P,hK as E,iS as M}from"./vendor.1dc52be5.js";function x(t){return t==="mesh"?q:C(t)}function I(t,e){return t?e?4:3:e?3:2}function U(t,e,r,i){return $(t,e,r,i.coords[0],i.coords[1])}function O(t,e,r,i,o,s){const n=I(o,s),{coords:p,lengths:a}=i;if(!a)return!1;for(let l=0,u=0;l<a.length;l++,u+=n)if(!$(t,e,r,p[u],p[u+1]))return!1;return!0}function $(t,e,r,i,o){if(!t)return!1;const s=I(e,r),{coords:n,lengths:p}=t;let a=!1,l=0;for(const u of p)a=T(a,n,s,l,u,i,o),l+=u*s;return a}function T(t,e,r,i,o,s,n){let p=t,a=i;for(let l=i,u=i+o*r;l<u;l+=r){a=l+r,a===u&&(a=i);const d=e[l],c=e[l+1],w=e[a],y=e[a+1];(c<n&&y>=n||y<n&&c>=n)&&d+(n-c)/(y-c)*(w-d)<s&&(p=!p)}return p}const S="feature-store:unsupported-query",W={esriSpatialRelIntersects:"intersects",esriSpatialRelContains:"contains",esriSpatialRelCrosses:"crosses",esriSpatialRelDisjoint:"disjoint",esriSpatialRelEnvelopeIntersects:"intersects",esriSpatialRelIndexIntersects:null,esriSpatialRelOverlaps:"overlaps",esriSpatialRelTouches:"touches",esriSpatialRelWithin:"within",esriSpatialRelRelation:null},G={spatialRelationship:{esriSpatialRelIntersects:!0,esriSpatialRelContains:!0,esriSpatialRelWithin:!0,esriSpatialRelCrosses:!0,esriSpatialRelDisjoint:!0,esriSpatialRelTouches:!0,esriSpatialRelOverlaps:!0,esriSpatialRelEnvelopeIntersects:!0,esriSpatialRelIndexIntersects:!1,esriSpatialRelRelation:!1},queryGeometry:{esriGeometryPoint:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!0},layerGeometry:{esriGeometryPoint:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!1}};function b(t){return G.spatialRelationship[t]===!0}function J(t){return G.queryGeometry[E(t)]===!0}function K(t){return G.layerGeometry[t]===!0}function V(){return import("./geometryEngineJSON.4db6c988.js")}function Z(t,e,r,i,o){if(h(e)&&r==="esriGeometryPoint"&&(t==="esriSpatialRelIntersects"||t==="esriSpatialRelContains")){const s=g(new v,e,!1,!1);return Promise.resolve(n=>U(s,!1,!1,n))}if(h(e)&&r==="esriGeometryMultipoint"){const s=g(new v,e,!1,!1);if(t==="esriSpatialRelContains")return Promise.resolve(n=>O(s,!1,!1,n,i,o))}if(R(e)&&r==="esriGeometryPoint"&&(t==="esriSpatialRelIntersects"||t==="esriSpatialRelContains"))return Promise.resolve(s=>j(e,f(r,i,o,s)));if(R(e)&&r==="esriGeometryMultipoint"&&t==="esriSpatialRelContains")return Promise.resolve(s=>D(e,f(r,i,o,s)));if(R(e)&&t==="esriSpatialRelIntersects"){const s=x(r);return Promise.resolve(n=>s(e,f(r,i,o,n)))}return V().then(s=>{const n=s[W[t]].bind(null,e.spatialReference,e);return p=>n(f(r,i,o,p))})}async function _(t,e,r){const{spatialRel:i,geometry:o}=t;if(o){if(!b(i))throw new m(S,"Unsupported query spatial relationship",{query:t});if(P(o.spatialReference)&&P(r)){if(!J(o))throw new m(S,"Unsupported query geometry type",{query:t});if(!K(e))throw new m(S,"Unsupported layer geometry type",{query:t});if(t.outSR)return M(t.geometry&&t.geometry.spatialReference,t.outSR)}}}function k(t){if(R(t))return!0;if(h(t)){for(const e of t.rings)if(e.length!==5||e[0][0]!==e[1][0]||e[0][0]!==e[4][0]||e[2][0]!==e[3][0]||e[0][1]!==e[3][1]||e[0][1]!==e[4][1]||e[1][1]!==e[2][1])return!1;return!0}return!1}export{k as I,_ as P,Z as v};
