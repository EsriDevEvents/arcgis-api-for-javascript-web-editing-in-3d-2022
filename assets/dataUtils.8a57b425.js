import{aM as C,g5 as E,br as H,gf as J,aH as q,ob as j,bJ as W,a8 as z}from"./vendor.1dc52be5.js";const G=C.getLogger("esri.views.2d.engine.flow.dataUtils"),R=9;async function tt(o,n,a){const c=performance.now(),i=K(o,n),s=performance.now(),t=Q(o,i,n.width,n.height),d=performance.now(),l=Y(t,!0),e=performance.now(),r=Z(l),f=performance.now();if(o.profile){const h={"_createFlowFieldFromData()":Math.round(s-c),"_getStreamlines()":Math.round(d-s),"createAnimatedLinesData()":Math.round(e-d),"createLinesMesh()":Math.round(f-e),"Total elapsed time":Math.round(f-c)};G.info("createStreamlinesMesh profile",h)}return await Promise.resolve(),E(a),r}function K(o,n){const a=X(n.data,n.width,n.height,o.smoothing);return o.interpolate?(c,i)=>{const s=Math.floor(c),t=Math.floor(i);if(s<0||s>=n.width)return[0,0];if(t<0||t>=n.height)return[0,0];const d=c-s,l=i-t,e=s,r=t,f=s<n.width-1?s+1:s,h=t<n.height-1?t+1:t,w=a[2*(r*n.width+e)],p=a[2*(r*n.width+f)],A=a[2*(h*n.width+e)],M=a[2*(h*n.width+f)],x=a[2*(r*n.width+e)+1],m=a[2*(r*n.width+f)+1];return[(w*(1-l)+A*l)*(1-d)+(p*(1-l)+M*l)*d,(x*(1-l)+a[2*(h*n.width+e)+1]*l)*(1-d)+(m*(1-l)+a[2*(h*n.width+f)+1]*l)*d]}:(c,i)=>{const s=Math.round(c),t=Math.round(i);return s<0||s>=n.width||t<0||t>=n.height?[0,0]:[a[2*(t*n.width+s)+0],a[2*(t*n.width+s)+1]]}}function N(o,n,a,c,i,s,t,d,l){const e=[];let r=a,f=c,h=0,[w,p]=n(r,f);w*=o.velocityScale,p*=o.velocityScale;const A=Math.sqrt(w*w+p*p);let M,x;e.push({x:r,y:f,t:h,speed:A});for(let m=0;m<o.verticesPerLine;m++){let[y,u]=n(r,f);y*=o.velocityScale,u*=o.velocityScale;const g=Math.sqrt(y*y+u*u);if(g<o.minSpeedThreshold)return e;const V=y/g,D=u/g;if(r+=V*o.segmentLength,f+=D*o.segmentLength,h+=o.segmentLength/g,Math.acos(V*M+D*x)>o.maxTurnAngle)return e;if(o.mergeLines){const L=Math.round(r*l),S=Math.round(f*l);if(L<0||L>t-1||S<0||S>d-1)return e;const F=s[S*t+L];if(F!==-1&&F!==i)return e;s[S*t+L]=i}e.push({x:r,y:f,t:h,speed:g}),M=V,x=D}return e}function Q(o,n,a,c){const i=[],s=new j,t=1/Math.max(o.lineCollisionWidth,1),d=Math.round(a*t),l=Math.round(c*t),e=new Int32Array(d*l);for(let f=0;f<e.length;f++)e[f]=-1;const r=[];for(let f=0;f<c;f+=o.lineSpacing)for(let h=0;h<a;h+=o.lineSpacing)r.push({x:h,y:f,sort:s.getFloat()});r.sort((f,h)=>f.sort-h.sort);for(const{x:f,y:h}of r)if(s.getFloat()<o.density){const w=N(o,n,f,h,i.length,e,d,l,t);if(w.length<2)continue;i.push(w)}return i}function X(o,n,a,c){if(c===0)return o;const i=Math.round(3*c),s=new Array(2*i+1);let t=0;for(let e=-i;e<=i;e++){const r=Math.exp(-e*e/(c*c));s[e+i]=r,t+=r}for(let e=-i;e<=i;e++)s[e+i]/=t;const d=new Float32Array(o.length);for(let e=0;e<a;e++)for(let r=0;r<n;r++){let f=0,h=0;for(let w=-i;w<=i;w++){if(r+w<0||r+w>=n)continue;const p=s[w+i];f+=p*o[2*(e*n+(r+w))+0],h+=p*o[2*(e*n+(r+w))+1]}d[2*(e*n+r)+0]=f,d[2*(e*n+r)+1]=h}const l=new Float32Array(o.length);for(let e=0;e<n;e++)for(let r=0;r<a;r++){let f=0,h=0;for(let w=-i;w<=i;w++){if(r+w<0||r+w>=a)continue;const p=s[w+i];f+=p*d[2*((r+w)*n+e)+0],h+=p*d[2*((r+w)*n+e)+1]}l[2*(r*n+e)+0]=f,l[2*(r*n+e)+1]=h}return l}function Y(o,n){const a=new j,c=o.reduce((l,e)=>l+e.length,0),i=new Float32Array(4*c),s=new Array(o.length);let t=0,d=0;for(const l of o){const e=t;for(const r of l)i[4*t+0]=r.x,i[4*t+1]=r.y,i[4*t+2]=r.t,i[4*t+3]=r.speed,t++;s[d++]={startVertex:e,numberOfVertices:l.length,totalTime:l[l.length-1].t,timeSeed:n?a.getFloat():0}}return{lineVertices:i,lineDescriptors:s}}function Z(o,n=10){const{lineVertices:a,lineDescriptors:c}=o;let i=0,s=0;for(const h of c)i+=2*h.numberOfVertices,s+=6*(h.numberOfVertices-1);const t=new Float32Array(i*R),d=new Uint32Array(s);let l=0,e=0;function r(){d[e++]=l-2,d[e++]=l,d[e++]=l-1,d[e++]=l,d[e++]=l+1,d[e++]=l-1}function f(h,w,p,A,M,x,m,y){const u=l*R;let g=0;t[u+g++]=h,t[u+g++]=w,t[u+g++]=1,t[u+g++]=p,t[u+g++]=x,t[u+g++]=m,t[u+g++]=A/2,t[u+g++]=M/2,t[u+g++]=y,l++,t[u+g++]=h,t[u+g++]=w,t[u+g++]=-1,t[u+g++]=p,t[u+g++]=x,t[u+g++]=m,t[u+g++]=-A/2,t[u+g++]=-M/2,t[u+g++]=y,l++}for(const h of c){const{totalTime:w,timeSeed:p}=h;let A=null,M=null,x=null,m=null,y=null,u=null;for(let g=0;g<h.numberOfVertices;g++){const V=a[4*(h.startVertex+g)+0],D=a[4*(h.startVertex+g)+1],L=a[4*(h.startVertex+g)+2],S=a[4*(h.startVertex+g)+3];let F=null,v=null,T=null,I=null;if(g>0){F=V-A,v=D-M;const k=Math.sqrt(F*F+v*v);if(F/=k,v/=k,g>1){let b=F+y,P=v+u;const B=Math.sqrt(b*b+P*P);b/=B,P/=B;const O=Math.min(1/(b*F+P*v),n);b*=O,P*=O,T=-P,I=b}else T=-v,I=F;T!==null&&I!==null&&(f(A,M,x,T,I,w,p,S),r())}A=V,M=D,x=L,y=F,u=v,m=S}f(A,M,x,-u,y,w,p,m)}return{vertexData:t,indexData:d}}function U(o,n){const a=n.pixels,{width:c,height:i}=n,s=new Float32Array(c*i*2);if(o==="vector-uv")for(let t=0;t<c*i;t++)s[2*t+0]=a[0][t],s[2*t+1]=-a[1][t];else if(o==="vector-magdir")for(let t=0;t<c*i;t++){const d=a[0][t],l=W(a[1][t]),e=Math.cos(l-Math.PI/2),r=Math.sin(l-Math.PI/2);s[2*t+0]=e*d,s[2*t+1]=r*d}return{data:s,width:c,height:i}}async function et(o,n,a,c,i,s){const t=H(n.spatialReference);if(!t)return _(o,n,a,c,i,s);const[d,l]=t.valid,e=l-d,r=Math.ceil(n.width/e),f=n.width/r,h=Math.round(a/r);let w=n.xmin;const p=[];for(let m=0;m<r;m++){const y=new J({xmin:w,xmax:w+f,ymin:n.ymin,ymax:n.ymax,spatialReference:n.spatialReference});p.push(_(o,y,h,c,i,s)),w+=f}const A=await Promise.all(p),M={data:new Float32Array(a*c*2),width:a,height:c};let x=0;for(const m of A){for(let y=0;y<m.height;y++)for(let u=0;u<m.width;u++)x+u>=a||(M.data[2*(y*a+x+u)+0]=m.data[2*(y*m.width+u)+0],M.data[2*(y*a+x+u)+1]=m.data[2*(y*m.width+u)+1]);x+=m.width}return M}async function _(o,n,a,c,i,s){const t={requestProjectedLocalDirections:!0,signal:s};if(z(i)&&(t.timeExtent=i),o.type==="imagery"){await o.load({signal:s});const e=o.rasterInfo.dataType,r=await o.fetchImage(n,a,c,t);return!r||q(r.pixelData)||q(r.pixelData.pixelBlock)?{data:new Float32Array(a*c*2),width:a,height:c}:U(e,r.pixelData.pixelBlock)}await o.load({signal:s});const d=o.rasterInfo.dataType,l=await o.fetchPixels(n,a,c,t);return!l||q(l.pixelBlock)?{data:new Float32Array(a*c*2),width:a,height:c}:U(d,l.pixelBlock)}export{tt as h,et as y};
