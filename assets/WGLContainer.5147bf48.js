var C=Object.defineProperty,M=Object.defineProperties;var b=Object.getOwnPropertyDescriptors;var w=Object.getOwnPropertySymbols;var $=Object.prototype.hasOwnProperty,U=Object.prototype.propertyIsEnumerable;var I=(a,e,t)=>e in a?C(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t,A=(a,e)=>{for(var t in e||(e={}))$.call(e,t)&&I(a,t,e[t]);if(w)for(var t of w(e))U.call(e,t)&&I(a,t,e[t]);return a},v=(a,e)=>M(a,b(e));import{aM as S,c8 as u,ty as D,g0 as E,V as _,i_ as H,cL as N,a8 as d,cc as R,cb as B,mM as y,oy as O,al as L,nI as V,aH as G,c9 as q,lk as P}from"./vendor.1dc52be5.js";import{w as F}from"./brushes.576aab26.js";import{s as W}from"./Container.a479a20a.js";import{w as c}from"./number.dc47462b.js";import{I as l}from"./Utils.25ecb0e0.js";const k=S.getLogger("esri.views.2d.engine.webgl.Mesh2D"),z=a=>{switch(a.BYTES_PER_ELEMENT){case 1:return y.UNSIGNED_BYTE;case 2:return y.UNSIGNED_SHORT;case 4:return y.UNSIGNED_INT;default:throw new _("Cannot get DataType of array")}},Y=(a,e,t,s)=>{let r=0;for(let i=1;i<t;i++){const n=a[2*(e+i-1)],o=a[2*(e+i-1)+1];r+=(a[2*(e+i)]-n)*(a[2*(e+i)+1]+o)}return s?r>0:r<0},T=({coords:a,lengths:e},t)=>{const s=[];for(let r=0,i=0;r<e.length;i+=e[r],r+=1){const n=i,o=[];for(;r<e.length-1&&Y(a,i+e[r],e[r+1],t);r+=1,i+=e[r])o.push(i+e[r]-n);const h=a.slice(2*n,2*(i+e[r])),p=O(h,o,2);for(const m of p)s.push(m+n)}return s};class f{constructor(e,t,s,r=!1){this._cache={},this.vertices=e,this.indices=t,this.primitiveType=s,this.isMapSpace=r}static fromRect({x:e,y:t,width:s,height:r}){const i=e,n=t,o=i+s,h=n+r;return f.fromScreenExtent({xmin:i,ymin:n,xmax:o,ymax:h})}static fromPath(e){const t=D(new E,e.path,!1,!1),s=t.coords,r=new Uint32Array(T(t,!0)),i=new Uint32Array(s.length/2);for(let n=0;n<i.length;n++)i[n]=c(Math.floor(s[2*n]),Math.floor(s[2*n+1]));return new f({geometry:i},r,u.TRIANGLES)}static fromGeometry(e,t){const s=t.geometry.type;switch(s){case"polygon":return f.fromPolygon(e,t.geometry);case"extent":return f.fromMapExtent(e,t.geometry);default:return k.error(new _("mapview-bad-type",`Unable to create a mesh from type ${s}`,t)),f.fromRect({x:0,y:0,width:1,height:1})}}static fromPolygon(e,t){const s=H(new E,t,!1,!1),r=s.coords,i=new Uint32Array(T(s,!1)),n=new Uint32Array(r.length/2),o=L(),h=L();for(let p=0;p<n.length;p++)N(o,r[2*p],r[2*p+1]),e.toScreen(h,o),n[p]=c(Math.floor(h[0]),Math.floor(h[1]));return new f({geometry:n},i,u.TRIANGLES,!0)}static fromScreenExtent({xmin:e,xmax:t,ymin:s,ymax:r}){const i={geometry:new Uint32Array([c(e,s),c(t,s),c(e,r),c(e,r),c(t,s),c(t,r)])},n=new Uint32Array([0,1,2,3,4,5]);return new f(i,n,u.TRIANGLES)}static fromMapExtent(e,t){const[s,r]=e.toScreen([0,0],[t.xmin,t.ymin]),[i,n]=e.toScreen([0,0],[t.xmax,t.ymax]),o={geometry:new Uint32Array([c(s,r),c(i,r),c(s,n),c(s,n),c(i,r),c(i,n)])},h=new Uint32Array([0,1,2,3,4,5]);return new f(o,h,u.TRIANGLES)}destroy(){d(this._cache.indexBuffer)&&this._cache.indexBuffer.dispose();for(const e in this._cache.vertexBuffers)d(this._cache.vertexBuffers[e])&&this._cache.vertexBuffers[e].dispose()}get elementType(){return z(this.indices)}getIndexBuffer(e,t=R.STATIC_DRAW){return this._cache.indexBuffer||(this._cache.indexBuffer=B.createIndex(e,t,this.indices)),this._cache.indexBuffer}getVertexBuffers(e,t=R.STATIC_DRAW){return this._cache.vertexBuffers||(this._cache.vertexBuffers=Object.keys(this.vertices).reduce((s,r)=>v(A({},s),{[r]:B.createVertex(e,t,this.vertices[r])}),{})),this._cache.vertexBuffers}}const j=S.getLogger("esri.views.2d.engine.webgl.ClippingInfo"),g=a=>parseFloat(a)/100;class x extends V{constructor(e,t){super(),this._clip=t,this._cache={},this.stage=e,this._handle=t.watch("version",()=>this._invalidate()),this.ready()}static fromClipArea(e,t){return new x(e,t)}_destroyGL(){d(this._cache.mesh)&&(this._cache.mesh.destroy(),this._cache.mesh=null),d(this._cache.vao)&&(this._cache.vao.dispose(),this._cache.vao=null)}destroy(){this._destroyGL(),this._handle.remove()}getVAO(e,t,s,r){const[i,n]=t.size;if(this._clip.type!=="geometry"&&this._lastWidth===i&&this._lastHeight===n||(this._lastWidth=i,this._lastHeight=n,this._destroyGL()),G(this._cache.vao)){const o=this._createMesh(t,this._clip),h=o.getIndexBuffer(e),p=o.getVertexBuffers(e);this._cache.mesh=o,this._cache.vao=new q(e,s,r,p,h)}return this._cache.vao}_createTransforms(){return{dvs:P()}}_invalidate(){this._destroyGL(),this.requestRender()}_createScreenRect(e,t){const[s,r]=e.size,i=typeof t.left=="string"?g(t.left)*s:t.left,n=typeof t.right=="string"?g(t.right)*s:t.right,o=typeof t.top=="string"?g(t.top)*r:t.top,h=typeof t.bottom=="string"?g(t.bottom)*r:t.bottom,p=i,m=o;return{x:p,y:m,width:Math.max(s-n-p,0),height:Math.max(r-h-m,0)}}_createMesh(e,t){switch(t.type){case"rect":return f.fromRect(this._createScreenRect(e,t));case"path":return f.fromPath(t);case"geometry":return f.fromGeometry(e,t);default:return j.error(new _("mapview-bad-type","Unable to create ClippingInfo mesh from clip of type: ${clip.type}")),f.fromRect({x:0,y:0,width:1,height:1})}}}class te extends W{constructor(){super(...arguments),this.name=this.constructor.name}set clips(e){this._clips=e,this.children.forEach(t=>t.clips=e),this._updateClippingInfo()}_createTransforms(){return{dvs:P()}}doRender(e){const t=this.createRenderParams(e),{painter:s,globalOpacity:r,profiler:i,drawPhase:n}=t,o=n===l.LABEL||n===l.HIGHLIGHT?1:r*this.computedOpacity;i.recordContainerStart(this.name),s.beforeRenderLayer(t,this._clippingInfos?255:0,o),this.updateTransforms(e.state),this.renderChildren(t),s.compositeLayer(t,o),i.recordContainerEnd()}renderChildren(e){G(this._renderPasses)&&(this._renderPasses=this.prepareRenderPasses(e.painter));for(const t of this.children)t.beforeRender(e);for(const t of this._renderPasses)try{t.render(e)}catch{}for(const t of this.children)t.afterRender(e)}createRenderParams(e){return e.requireFBO=this.requiresDedicatedFBO,e}prepareRenderPasses(e){return[e.registerRenderPass({name:"clip",brushes:[F.clip],target:()=>this._clippingInfos,drawPhase:l.MAP|l.LABEL|l.LABEL_ALPHA|l.DEBUG|l.HIGHLIGHT})]}updateTransforms(e){for(const t of this.children)t.setTransform(e)}onAttach(){super.onAttach(),this._updateClippingInfo()}onDetach(){super.onDetach(),this._updateClippingInfo()}_updateClippingInfo(){if(d(this._clippingInfos)&&(this._clippingInfos.forEach(t=>t.destroy()),this._clippingInfos=null),!this.stage)return;const e=this._clips;d(e)&&e.length&&(this._clippingInfos=e.items.map(t=>x.fromClipArea(this.stage,t))),this.requestRender()}}export{te as a};
