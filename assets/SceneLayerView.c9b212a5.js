import{aF as L,a8 as V,aH as G,kt as S,ku as j,ac as o,ad as l,ae as O,aM as q,n6 as R,n7 as k,aN as z,a6 as E,b1 as B,hV as K,mm as H,fG as Q}from"./vendor.1dc52be5.js";import{n as M}from"./attributeUtils.987422a2.js";const J={setAttribute(){},rollback(){},commit(){}};var I;function se(e,r){const t=r.attributes[e.objectIdField],n=e.sessions.get(t);if(n)return n;const s=L(r.attributes),a=new Set;if(t==null)return J;const u=e.attributeOverrides.createInteractiveEditSession(t),c=new Map,w=(d,m)=>{const p=c.get(d);if(p==null){const f=m.indexOf(t);return c.set(d,f),f}return p};let i=I.EDITING;const y={setAttribute(d,m){if(i!==I.EDITING)return;const p=e.fieldsIndex.get(d);if(G(p))return;const f=e.attributeStorageInfo.findIndex(b=>b.name===p.name);if(f<0)return;u.set(f,m);const F=e.attributeStorageInfo[f];let x=!1;a.add(d),e.forEachNode((b,A)=>{const D=w(b,A);if(D===-1)return;const U=e.getAttributeData(b.index);if(U){const _=U[F.name];_&&(_[D]=m,e.setAttributeData(b.index,U,r),x=!0)}}),x&&e.clearMemCache()},rollback(){if(i===I.EDITING){for(const d of a)this.setAttribute(d,s[d]);u.rollback(),i=I.ROLLED_BACK,e.sessions.delete(t)}},commit(){i===I.EDITING&&(u.commit(),i=I.COMMITTED,e.sessions.delete(t))}};return e.sessions.set(t,y),y}function ae(e,r){const t=P(e,r);if(t.size===0)return;const n=new Map;for(let a=0;a<e.attributeStorageInfo.length;a++)n.set(e.attributeStorageInfo[a].name,a);let s=!1;t.forEach((a,u)=>{const c=e.getAttributeData(u);let w=!1;a.forEach((i,y)=>{const d=V(c)?c[y]:null,m=n.get(y);for(const{featureIndex:p,value:f,featureId:F}of i)d&&(d[p]=f,w=!0,s=!0),e.attributeOverrides.updateValue(F,m,f)}),w&&e.setAttributeData(u,c,null)}),s&&e.clearMemCache()}function P(e,r){const t=r.edits.updateFeatures;if(!t||t.length===0)return new $;const n=Y(r),s=new $,a=new Map;for(let i=0;i<e.attributeStorageInfo.length;i++)a.set(e.attributeStorageInfo[i].name,i);const u=e.fieldsIndex,c=e.objectIdField,w=t.filter(i=>{const y=M(u,i.attributes,c);return n.has(y)});return e.forEachNode((i,y)=>{const d=new Set(y);for(const m of w){const p=M(u,m.attributes,c);if(!d.has(p))continue;const f=y.indexOf(p);for(const F in m.attributes){const x=e.fieldsIndex.normalizeFieldName(F),b=W(s,i.index,x),A=m.attributes[F];b.push({featureIndex:f,featureId:p,value:A})}}}),s}function W(e,r,t){const n=X(e,r),s=n.get(t);if(s)return s;const a=new Array;return n.set(t,a),a}function X(e,r){const t=e.get(r);if(t)return t;const n=new Z;return e.set(r,n),n}function Y(e){const r=new Set;if(!e.updatedFeatures)return r;for(const t of e.updatedFeatures)t.objectId!=null&&t.error==null&&r.add(t.objectId);return r}(function(e){e[e.EDITING=0]="EDITING",e[e.ROLLED_BACK=1]="ROLLED_BACK",e[e.COMMITTED=2]="COMMITTED"})(I||(I={}));const Z=Map,$=Map;function ie(){return{requiredFields:{type:[String],readOnly:!0},availableFields:{type:[String],readOnly:!0,get:function(){const{layer:e,layer:{fieldsIndex:r},requiredFields:t}=this;return e.outFields?S(r,[...j(r,e.outFields),...t]):S(r,t)}}}}const C=e=>{let r=class extends e{constructor(){super(...arguments),this._numUpdating=0,this.asyncUpdateState=new Map}get updating(){return this._numUpdating>0}autoUpdateAsync(t,n){return ee(s=>this._updateAsync(t,s),n)}async _updateAsync(t,n){if(!this._startAsyncUpdate(t)){try{const s=await n();this._set(t,s)}catch{q.getLogger(this.declaredClass).warn(`Async update of "${t}" failed. Async update functions should not throw exceptions.`)}this._endAsyncUpdate(t)&&this._updateAsync(t,n)}}_startAsyncUpdate(t){var n;const s=(n=this.asyncUpdateState.get(t))!=null?n:h.None;return s&h.Updating?(this.asyncUpdateState.set(t,s|h.Invalidated),!0):(++this._numUpdating,this.asyncUpdateState.set(t,s|h.Updating),!1)}_endAsyncUpdate(t){var n;--this._numUpdating;const s=((n=this.asyncUpdateState.get(t))!=null?n:h.None)&~h.Updating;return s&h.Invalidated?(this.asyncUpdateState.set(t,s&~h.Invalidated),!0):(this.asyncUpdateState.set(t,s),!1)}};return o([l({readOnly:!0})],r.prototype,"updating",null),o([l()],r.prototype,"_numUpdating",void 0),r=o([O("esri.core.AsyncUpdate")],r),r};var h;function ee(e,r){const t=()=>{a&&!u&&e(n)},n=()=>{if(!a||u)return r();a.clear(),u=!0;const c=R(a,r);return u=!1,c},s=()=>{a&&(a.destroy(),a=null)};let a=new k(t),u=!1;return e(n),{remove:s}}(function(e){e[e.None=0]="None",e[e.Updating=1]="Updating",e[e.Invalidated=2]="Invalidated"})(h||(h={}));let T=class extends C(z){};T=o([O("esri.core.AsyncUpdate")],T);const te=q.getLogger("esri.views.3d.layers.support.SceneLayerViewRequiredFields");let g=class extends C(B){constructor(e){super(e)}get requiredFields(){const{layerView:{layer:{fieldsIndex:e},definitionExpressionFields:r},rendererFields:t,labelingFields:n,viewFilterFields:s}=this;return S(e,[...E(r,[]),...E(t,[]),...E(n,[]),...E(s,[])])}initialize(){const e=this.layerView.layer;this.layer=e,this.handles.add([this.autoUpdateAsync("rendererFields",()=>{const{fieldsIndex:r,renderer:t}=this.layer;return t?N(n=>t.collectRequiredFields(n,r)):null}),this.autoUpdateAsync("labelingFields",()=>{const{layer:r}=this;return r.labelsVisible?N(t=>K(t,r)):null}),this.autoUpdateAsync("viewFilterFields",()=>{const{layer:r,filter:t}=this.layerView;return N(n=>H(n,r,t))})])}};async function N(e){const r=new Set;try{return await e(r),Array.from(r).sort()}catch(t){return te.error(t),null}}o([l()],g.prototype,"layerView",void 0),o([l()],g.prototype,"layer",void 0),o([l()],g.prototype,"requiredFields",null),o([l()],g.prototype,"rendererFields",void 0),o([l()],g.prototype,"labelingFields",void 0),o([l()],g.prototype,"viewFilterFields",void 0),g=o([O("esri.views.3d.layers.support.SceneLayerViewRequiredFields")],g);class v extends Q{constructor(){super(...arguments),this.layer=null,this.filter=null}get availableFields(){return[]}get maximumNumberOfFeatures(){return 0}set maximumNumberOfFeatures(r){throw new Error("Not implemented")}get maximumNumberOfFeaturesExceeded(){return!1}highlight(r){throw new Error("Not implemented")}queryFeatures(r,t){throw new Error("Not implemented")}queryObjectIds(r,t){throw new Error("Not implemented")}queryFeatureCount(r,t){throw new Error("Not implemented")}createQuery(){throw new Error("Not implemented")}queryExtent(r,t){throw new Error("Not implemented")}}o([l()],v.prototype,"layer",void 0),o([l()],v.prototype,"availableFields",null),o([l()],v.prototype,"maximumNumberOfFeatures",null),o([l({readOnly:!0})],v.prototype,"maximumNumberOfFeaturesExceeded",null),o([l()],v.prototype,"filter",void 0);export{ae as a,ie as b,g as c,se as i,v as o};
