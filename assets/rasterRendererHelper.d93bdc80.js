var F=Object.defineProperty,G=Object.defineProperties;var H=Object.getOwnPropertyDescriptors;var J=Object.getOwnPropertySymbols;var U=Object.prototype.hasOwnProperty,K=Object.prototype.propertyIsEnumerable;var I=(t,e,r)=>e in t?F(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,N=(t,e)=>{for(var r in e||(e={}))U.call(e,r)&&I(t,r,e[r]);if(J)for(var r of J(e))K.call(e,r)&&I(t,r,e[r]);return t},_=(t,e)=>G(t,H(e));import{ac as g,ad as B,vG as x,ae as Q,f9 as X,aF as Y,hl as z,nC as Z,V as p,qC as y,a8 as s,vH as A,vI as ee,a7 as T,vJ as te,hP as ne,vK as re,vL as V,b7 as P,qS as D,P as ae,vM as ie,vN as oe}from"./vendor.1dc52be5.js";import{l as le}from"./RasterSymbolizer.e82db03b.js";var j;let w=j=class extends X{constructor(t){super(t),this.variableName=null,this.dimensionName=null,this.values=[],this.isSlice=!1}clone(){return new j({variableName:this.variableName,dimensionName:this.dimensionName,values:Y(this.values),isSlice:this.isSlice})}};g([B({type:String,json:{write:!0}})],w.prototype,"variableName",void 0),g([B({type:String,json:{write:!0}})],w.prototype,"dimensionName",void 0),g([B({type:x.array(x.oneOf([x.native(Number),x.array(x.native(Number))])),json:{write:!0}})],w.prototype,"values",void 0),g([B({type:Boolean,json:{write:!0}})],w.prototype,"isSlice",void 0),w=j=g([Q("esri.layers.support.DimensionalDefinition")],w);const Pe=w,Me=z()({RSP_NearestNeighbor:"nearest",RSP_BilinearInterpolation:"bilinear",RSP_CubicConvolution:"cubic",RSP_Majority:"majority"}),Ce=z()({esriNoDataMatchAny:"any",esriNoDataMatchAll:"all"});class je{constructor(){this._workerThread=null,this._destroyed=!1}async initialize(){const e=await Z("RasterWorker");this._destroyed?e.close():this._workerThread=e}destroy(){this._destroyed=!0,this._workerThread&&(this._workerThread.close(),this._workerThread=null)}async convertVectorFieldData(e,r){if(!this._workerThread)throw new p("raster-jobhandler:no-connection","no available worker connection");const n=await this._workerThread.invoke("convertVectorFieldData",{pixelBlock:e.pixelBlock.toJSON(),type:e.dataType},r);return n?new y(n):null}async decode(e,r){if(!this._workerThread)throw new p("raster-jobhandler:no-connection","no available worker connection");const n=await this._workerThread.invoke("decode",e,r);return n?new y(n):null}async symbolize(e,r){if(!this._workerThread)throw new p("raster-jobhandler:no-connection","no available worker connection");const n={extent:e.extent&&e.extent.toJSON(),pixelBlock:s(e.pixelBlock)&&e.pixelBlock.toJSON(),simpleStretchParams:e.simpleStretchParams,bandIds:e.bandIds},a=await this._workerThread.invoke("symbolize",n,r);return a?new y(a):null}async updateSymbolizer(e,r){var n;if(!this._workerThread)throw new p("raster-jobhandler:no-connection","no available worker connection");const a=e==null||(n=e.rendererJSON)==null?void 0:n.histograms;await Promise.all(this._workerThread.broadcast("updateSymbolizer",{symbolizerJSON:e.toJSON(),histograms:a},r))}async stretch(e,r){if(!this._workerThread)throw new p("raster-jobhandler:no-connection","no available worker connection");if(e==null||!e.pixelBlock)return null;const n={srcPixelBlock:e.pixelBlock.toJSON(),stretchParams:e.stretchParams},a=await this._workerThread.invoke("stretch",n,r);return a?new y(a):null}async split(e,r){if(!this._workerThread)throw new p("raster-jobhandler:no-connection","no available worker connection");if(e==null||!e.pixelBlock)return null;const n={srcPixelBlock:e.pixelBlock.toJSON(),tileSize:e.tileSize,maximumPyramidLevel:e.maximumPyramidLevel},a=await this._workerThread.invoke("split",n,r);return a&&a.forEach((i,o)=>{a.set(o,i?y.fromJSON(i):null)}),Promise.resolve(a)}async estimateStatisticsHistograms(e,r){if(!this._workerThread)throw new p("raster-jobhandler:no-connection","no available worker connection");if(e==null||!e.pixelBlock)return null;const n={srcPixelBlock:e.pixelBlock.toJSON()},a=await this._workerThread.invoke("estimateStatisticsHistograms",n,r);return Promise.resolve(a)}async mosaicAndTransform(e,r){var n;if(!this._workerThread)throw new p("raster-jobhandler:no-connection","no available worker connection");if(e==null||(n=e.srcPixelBlocks)==null||!n.length)return{pixelBlock:null};const a=_(N({},e),{srcPixelBlocks:e.srcPixelBlocks.map(o=>s(o)?o.toJSON():null)}),i=await this._workerThread.invoke("mosaicAndTransform",a,r);return{pixelBlock:i.pixelBlock?new y(i.pixelBlock):null,localNorthDirections:i.localNorthDirections}}async createStreamlinesMesh(e,r){if(!this._workerThread)throw new p("raster-jobhandler:no-connection","no available worker connection");const n={buffer:e.flowData.data.buffer,width:e.flowData.width,height:e.flowData.height},a=e.rendererSettings,i=await this._workerThread.invoke("createStreamlinesMesh",{flowData:n,rendererSettings:a},_(N({},r),{transferList:[n.buffer]}));return{vertexData:new Float32Array(i.vertexBuffer),indexData:new Uint32Array(i.indexBuffer)}}getProjectionOffsetGrid(e,r){if(!this._workerThread)throw new p("raster-jobhandler:no-connection","no available worker connection");const n=s(e.datumTransformation)?e.datumTransformation.steps.map(o=>({wkid:o.wkid,wkt:o.wkt,isInverse:o.isInverse})):null,a=s(e.rasterTransform)?e.rasterTransform.toJSON():null,i={projectedExtent:e.projectedExtent.toJSON(),srcBufferExtent:e.srcBufferExtent.toJSON(),pixelSize:e.pixelSize,hasWrapAround:e.hasWrapAround,spacing:e.spacing,datumTransformationSteps:n,rasterTransform:a,isAdaptive:e.isAdaptive,includeGCSGrid:e.includeGCSGrid};return this._workerThread.invoke("getProjectionOffsetGrid",i,r)}}const se=.25,ue=A.fromJSON({type:"multipart",colorRamps:[{fromColor:[0,0,255],toColor:[0,255,255]},{fromColor:[0,255,255],toColor:[255,255,0]},{fromColor:[255,255,0],toColor:[255,0,0]}]}),$=A.fromJSON(ee[0]),E=new Set(["scientific","standard-time","vector-uv","vector-magdir","vector-u","vector-v","vector-magnitude","vector-direction"]);function Oe(t,e){const{attributeTable:r,colormap:n}=t;if(O(t)){const a=Se(t);if(s(a))return a}if(s(n)){const a=ve(t);if(s(a))return a}if(s(r)){const a=pe(t);if(s(a))return a}return ce(t,e)}function Je(t){const e=["raster-stretch"];return q(t)&&e.push("raster-colormap"),W(t)&&e.push("unique-value"),ye(t)&&e.push("class-breaks"),we(t)&&e.push("raster-shaded-relief"),O(t)&&e.push("vector-field"),ge(t)&&e.push("flow"),e}function Ie(t,e,r){const n=["nearest","bilinear","cubic","majority"].find(a=>a===(r==null?void 0:r.toLowerCase()));return e==="Map"?n!=null?n:"bilinear":t.dataType==="standard-time"?n!=null?n:"nearest":t.dataType==="thematic"||t.attributeTable||t.colormap?n==="nearest"||n==="majority"?n:"nearest":n!=null?n:"bilinear"}function ce(t,e){var r,n,a,i;t=me(t,e==null?void 0:e.variableName);const{bandCount:o}=t;let{bandIds:l,stretchType:m}=e||{};(r=l)!=null&&r.some(f=>f>=o)&&(l=null);let d=T(t.statistics),b=T(t.histograms);var h;o>1?(l=(h=l)!=null&&h.length?l:de(t),d=d==null?null:l.map(f=>d[f]),b=b==null?null:l.map(f=>b[f])):l=[0],m==null&&(m=fe(t));let v=!1;switch(m){case"none":v=!1;break;case"percent-clip":v=!((n=b)!=null&&n.length);break;default:v=!((a=d)!=null&&a.length)}const{dataType:k}=t,u=((i=l)==null?void 0:i.length)===1&&E.has(k)?ue:null,c=new te({stretchType:m,dynamicRangeAdjustment:v,colorRamp:u,outputMin:0,outputMax:255,gamma:l.length===1?[1]:[1,1,1],useGamma:!1});return m==="percent-clip"?c.maxPercent=c.minPercent=se:m==="standard-deviation"&&(c.numberOfStandardDeviations=2),!v&&(s(t.multidimensionalInfo)||e!=null&&e.includeStatisticsInStretch)&&(m==="percent-clip"?c.histograms=b:m!=="min-max"&&m!=="standard-deviation"||(c.statistics=d)),c}function me(t,e){if(e==null)return t;let r=T(t.statistics),n=T(t.histograms);const{multidimensionalInfo:a}=t;if(e&&s(a)){const{statistics:i,histograms:o}=a.variables.find(l=>l.name===e);i!=null&&i.length&&(r=i),o!=null&&o.length&&(n=o)}return le.fromJSON(_(N({},t.toJSON()),{statistics:r,histograms:n}))}function de(t){const e=t.bandCount;if(e===1)return null;if(e===2)return[0];const r=t.keyProperties&&t.keyProperties.BandProperties;let n;if(r&&r.length===e){const{red:a,green:i,blue:o,nir:l}=he(r);a!=null&&i!=null&&o!=null?n=[a,i,o]:l!=null&&a!=null&&i!=null&&(n=[l,a,i])}return!n&&e>=3&&(n=[0,1,2]),n}function he(t){const e={};for(let n=0;n<t.length;n++){var r;const a=t[n],i=(r=a.BandName)==null?void 0:r.toLowerCase();if(i==="red")e.red=n;else if(i==="green")e.green=n;else if(i==="blue")e.blue=n;else if(i==="nearinfrared"||i==="nearinfrared_1"||i==="nir")e.nir=n;else if(a.WavelengthMax&&a.WavelengthMin){const o=a.WavelengthMin,l=a.WavelengthMax;e.blue==null&&o>=410&&o<=480&&l>=480&&l<=540?e.blue=n:e.green==null&&o>=490&&o<=560&&l>=560&&l<=610?e.green=n:e.red==null&&o>=595&&o<=670&&l>=660&&l<=730?e.red=n:e.nir==null&&o>=700&&o<=860&&l>=800&&l<=950&&(e.nir=n)}}return e}function fe(t){let e="percent-clip";const{pixelType:r,dataType:n,histograms:a,statistics:i}=t;return r!=="u8"||n!=="processed"&&s(a)&&s(i)?r==="u8"||n==="elevation"||E.has(n)?e="min-max":s(a)?e="percent-clip":s(i)&&(e="min-max",e="min-max"):e="none",e}function pe(t,e,r,n){if(!W(t,e))return null;const{attributeTable:a,statistics:i}=t,o=R(a,e),l=S(a,"red"),m=S(a,"green"),d=S(a,"blue"),b=new re,h=[],v=new Set,k=!!(l&&m&&d);if(s(a))a.features.forEach(u=>{const c=u.attributes[o.name];if(!v.has(u.attributes[o.name])&&c!=null){v.add(c);const f=k&&(l.type==="single"||l.type==="double")&&(m.type==="single"||m.type==="double")&&(d.type==="single"||d.type==="double")&&!a.features.some(C=>C.attributes[l.name]>1||C.attributes[m.name]>1||C.attributes[d.name]>1),M=f?255:1;h.push(new V({value:u.attributes[o.name],label:u.attributes[o.name]+"",symbol:{type:"simple-fill",style:"solid",outline:null,color:new P(k?[u.attributes[l.name]*M,u.attributes[m.name]*M,u.attributes[d.name]*M,1]:[0,0,0,0])}}))}});else if(i!=null&&i[0])for(let u=i[0].min;u<=i[0].max;u++)h.push(new V({value:u,label:u.toString(),symbol:{type:"simple-fill",style:"solid",outline:null,color:new P([0,0,0,0])}}));if(h.sort((u,c)=>u.value&&typeof u.value.valueOf()=="string"?0:u.value>c.value?1:-1),!k){const u=D($,h.length);h.forEach((c,f)=>c.symbol.color=new P(u[f].slice(1,4))),b.colorRamp=$}if(r||n){const u=r||D(n,h.length).map(c=>c.slice(1));h.forEach((c,f)=>c.symbol.color=new P(u[f])),b.colorRamp=n}return new ae({field:o.name,uniqueValueInfos:h,authoringInfo:b})}function R(t,e,r){let n;return s(t)?(n=e?t.fields.find(a=>e.toLowerCase()===a.name.toLowerCase()):be(t.fields),n||(r||(n=t.fields.find(a=>a.type==="string")),n||(n=S(t,"value")))):n=new ne({name:"value"}),n}function be(t){let e;for(let r=0;r<t.length;r++){const n=t[r].name.toLowerCase();if(t[r].type==="string"){if(n.startsWith("class")){e=t[r];break}e==null&&(n.endsWith("name")||n.endsWith("type"))&&(e=t[r])}}return e}function S(t,e){return s(t)?t.fields.find(r=>r.name.toLowerCase()===e):null}function W(t,e){const{attributeTable:r,bandCount:n}=t;return!s(r)&&ke(t)?!0:!(!s(r)||n>1||e&&r.fields.find(a=>a.name.toLowerCase()===e.toLowerCase())==null)}function q(t){const{bandCount:e,colormap:r}=t;return s(r)&&r.length&&e===1}function ve(t){if(!q(t))return null;let e;const{attributeTable:r,colormap:n}=t;if(s(r)){const a=S(r,"value"),i=R(r,null,!0);i.type==="string"&&(e={},r.features.forEach(o=>{const l=o.attributes;e[l[a.name]]=i?l[i.name]:l[a.name]}))}return ie.createFromColormap(T(n),e)}function we(t){return t.dataType==="elevation"}function ye(t){const{attributeTable:e,bandCount:r}=t;return r===1&&(s(e)||s(t.histograms))}function ke(t){var e,r,n;return["u8","s8"].indexOf(t.pixelType)>-1&&((e=t.statistics)==null||(r=e[0])==null?void 0:r.min)!=null&&((n=t.statistics[0])==null?void 0:n.max)!=null&&t.bandCount===1}function O(t){const{dataType:e}=t;return e==="vector-uv"||e==="vector-magdir"}function ge(t){const{dataType:e}=t;return e==="vector-uv"||e==="vector-magdir"}const xe=new Map([["m/s","meter-per-second"],["km/h","kilometer-per-hour"],["knots","knots"],["ft/s","feet-per-second"],["mph","mile-per-hour"]]);function Se(t){if(!O(t))return null;let e;if(s(t.statistics)&&t.statistics.length&&(t.dataType==="vector-magdir"||t.dataType==="vector-uv")){const{minMagnitude:a,maxMagnitude:i}=Te(t.dataType,t.statistics);e=[{type:"size",field:"Magnitude",minSize:10,maxSize:40,minDataValue:a,maxDataValue:i}]}const r=s(t.multidimensionalInfo)?xe.get(t.multidimensionalInfo.variables[0].unit):null,n=new oe({visualVariables:e,inputUnit:r,rotationType:"geographic"});return n.visualVariables=[...n.sizeVariables,...n.rotationVariables],n}function L(t){var e;return{color:(e=t.symbolLayers[0].material)==null?void 0:e.color,type:"esriSFS",style:"esriSFSSolid"}}function Ve(t){if(t.type==="uniqueValue"){var e;const n=t.uniqueValueInfos,a=n[0].symbol;return a!=null&&(e=a.symbolLayers)!=null&&e.length&&(t.uniqueValueInfos=n.map(i=>({value:i.value,label:i.label,symbol:i.symbol?L(i.symbol):null}))),t}if(t.type==="classBreaks"){var r;const n=t.classBreakInfos,a=n[0].symbol;return a!=null&&(r=a.symbolLayers)!=null&&r.length&&(t.classBreakInfos=n.map(i=>({classMinValue:i.classMinValue,classMaxValue:i.classMaxValue,label:i.label,symbol:i.symbol?L(i.symbol):null}))),t}return t}function Te(t,e){let r,n;if(t==="vector-magdir")r=e[0].min,n=e[0].max;else{const a=e[0].min,i=e[0].max,o=e[1].min,l=e[1].max;r=0,n=Math.max(Math.abs(a),Math.abs(o),Math.abs(i),Math.abs(l))}return{minMagnitude:r,maxMagnitude:n}}export{de as L,Ie as V,Ve as e,Ce as i,Oe as j,Je as k,je as n,Me as o,Pe as p};
